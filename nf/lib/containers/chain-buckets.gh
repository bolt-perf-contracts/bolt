#ifndef CHAIN_BUCKETS_GH
#define CHAIN_BUCKETS_GH

#include "stdex.gh"
#include "nth_prop.gh"
#include "natlist.gh"

inductive bucket<kt> = bucket(list<pair<kt, nat> >);
//list<bucket<kt> > - the map.

fixpoint list<pair<kt, nat> > advance_acc<kt>(list<pair<kt, nat> > acc) {
  switch(acc) {
    case nil: return nil;
    case cons(h,t):
      return switch(h) {
        case pair(key,distance):
          return switch(distance) {
            case zero: return advance_acc(t);
            case succ(n): return cons(pair(fst(h), n),
                                      advance_acc(t));
          };
      };
  }
}

fixpoint option<kt> get_current_key_fp<kt>(list<pair<kt, nat> > acc) {
  switch(acc) {
    case nil: return none;
    case cons(h,t):
      return switch(h) {
        case pair(key,distance):
          return switch(distance) {
            case zero: return some(key);
            case succ(n): return get_current_key_fp(t);
          };
      };
  }
}

fixpoint list<pair<kt, nat> > acc_at_this_bucket<kt>(list<pair<kt, nat> > acc,
                                                     bucket<kt> next_bucket) {
  switch(next_bucket) { case bucket(tails): return append(acc, tails);}
}

fixpoint list<pair<kt, nat> > get_wraparound<kt>(list<pair<kt, nat> > acc,
                                                 list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil: return acc;
    case cons(h,t):
      return get_wraparound(advance_acc(acc_at_this_bucket(acc, h)), t);
  }
}

fixpoint bool buckets_ok_rec<kt>(list<pair<kt, nat> > acc,
                                 list<bucket<kt> > buckets,
                                 int bound) {
  switch(buckets) {
    case nil:
      return distinct(map(snd, acc)) &&
      forall(acc, (sup)((nat_lt)(bound - 1), snd));
    case cons(bkh,bkt):
      return distinct(map(snd, acc_at_this_bucket(acc, bkh))) &&
      forall(acc_at_this_bucket(acc, bkh), (sup)((nat_lt)(bound), snd)) &&
      buckets_ok_rec(advance_acc(acc_at_this_bucket(acc, bkh)),
                     bkt, bound);
  }
}

fixpoint bool not_this_key_pair_fp<kt>(kt k, pair<kt, nat> p) {
  return fst(p) != k;
}

fixpoint list<bucket<kt> > buckets_remove_key_fp<kt>(list<bucket<kt> > buckets,
                                                     kt k) {
  switch(buckets) {
    case nil: return nil;
    case cons(bh,bt):
      return switch(bh) {
        case bucket(chains):
          return cons(bucket(filter((not_this_key_pair_fp)(k), chains)),
                      buckets_remove_key_fp(bt, k));
      };
  }
}

fixpoint bucket<kt> bucket_put_key_fp<kt>(bucket<kt> b,
                                          kt k, int dist) {
  switch(b) {
    case bucket(chains):
      return bucket(cons(pair(k, nat_of_int(dist)), chains));
  }
}

fixpoint list<bucket<kt> > buckets_put_key_fp<kt>(list<bucket<kt> > buckets,
                                                  kt k,
                                                  int start, int dist) {
  switch(buckets) {
    case nil: return nil;
    case cons(h,t):
      return (start == 0) ?
      cons(bucket_put_key_fp(h, k, dist), t) :
      cons(h, buckets_put_key_fp(t, k, start - 1, dist));
  }
}

fixpoint list<kt> buckets_all_keys_fp<kt>(list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil:
      return nil;
    case cons(h,t):
      return switch(h) {
        case bucket(chains):
          return append(map(fst, chains), buckets_all_keys_fp(t));
      };
  }
}

fixpoint bool buckets_ok<kt>(list<bucket<kt> > buckets) {
  return
  true == distinct(buckets_all_keys_fp(buckets)) &&
  buckets_ok_rec(get_wraparound(nil, buckets), buckets, length(buckets));
}

fixpoint list<int> buckets_get_chns_rec_fp<kt>(list<pair<kt, nat> > acc,
                                               list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil: return nil;
    case cons(bh,bt):
      return cons(length(advance_acc(acc_at_this_bucket(acc, bh))),
                  buckets_get_chns_rec_fp(advance_acc
                                          (acc_at_this_bucket(acc, bh)),
                                          bt));
  }
}

fixpoint list<int> buckets_get_chns_fp<kt>(list<bucket<kt> > buckets) {
  return buckets_get_chns_rec_fp(get_wraparound(nil, buckets), buckets);
}

fixpoint list<option<kt> > buckets_get_keys_rec_fp<kt>(list<pair<kt, nat> > acc,
                                                       list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil: return nil;
    case cons(bh,bt):
      return cons(get_current_key_fp(acc_at_this_bucket(acc, bh)),
                  buckets_get_keys_rec_fp(advance_acc
                                          (acc_at_this_bucket(acc, bh)),
                                          bt));
  }
}

fixpoint list<option<kt> > buckets_get_keys_fp<kt>(list<bucket<kt> > buckets) {
  return buckets_get_keys_rec_fp(get_wraparound(nil, buckets), buckets);
}

lemma void buckets_ok_wraparound_bounded_rec<kt>(list<pair<kt, nat> > acc,
                                                 list<bucket<kt> > buckets,
                                                 int bound)
requires true == buckets_ok_rec(acc, buckets, bound);
ensures true == forall(get_wraparound(acc, buckets),
                       (sup)((nat_lt)(bound - 1), snd));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_ok_wraparound_bounded_rec
      (advance_acc(acc_at_this_bucket(acc, h)),
       t, bound);
  }
}

lemma void advance_chain_contains<kt>(kt key, nat prev_tail,
                                      list<pair<kt, nat> > acc2)
requires true == contains(acc2, pair(key, succ(prev_tail)));
ensures true == contains(advance_acc(acc2), pair(key, prev_tail));
{
  switch(acc2) {
    case nil:
    case cons(h,t):
      if (h == pair(key, succ(prev_tail))) {
      } else {
        advance_chain_contains(key, prev_tail, t);
        switch(h) {
          case pair(k,d):
            switch(d) {
              case zero:
              case succ(n):
            }
        }
      }
  }
}

lemma void advance_acc_subset<kt>(list<pair<kt, nat> > acc1,
                                  list<pair<kt, nat> > acc2)
requires true == subset(acc1, acc2);
ensures true == subset(advance_acc(acc1), advance_acc(acc2));
{
  switch(acc1) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(k, dist):
          switch(dist) {
            case zero:
            case succ(prev_dist):
              advance_chain_contains(k, prev_dist, acc2);
          }
      }
    advance_acc_subset(t, acc2);
  }
}

lemma void advance_acc_subset_keys<kt>(list<pair<kt, nat> > acc)
requires true;
ensures true == msubset(map(fst, advance_acc(acc)),
                        map(fst, acc)) &*&
        true == subset(map(fst, advance_acc(acc)),
                       map(fst, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(k,dist):
          advance_acc_subset_keys(t);
          switch(dist) {
            case zero:
              msubset_append(cons(k, nil), map(fst, t));
              msubset_trans(map(fst, advance_acc(acc)),
                            map(fst, t),
                            map(fst, acc));
              msubset_subset(map(fst, advance_acc(acc)), map(fst, acc));
            case succ(n):
              msubset_subset(map(fst, advance_acc(acc)), map(fst, acc));
          }
      }
  }
}//took 15m

lemma void acc_at_this_bucket_subset<kt>(list<pair<kt, nat> > acc1,
                                         list<pair<kt, nat> > acc2,
                                         bucket<kt> b)
requires true == subset(acc1, acc2);
ensures true == subset(acc_at_this_bucket(acc1, b),
                       acc_at_this_bucket(acc2, b));
{
  switch(b) {
    case bucket(chains):
      append_both_subset(acc1, chains, acc2);
  }
}

lemma void subset_wraparound<kt>(list<pair<kt, nat> > acc1,
                                 list<pair<kt, nat> > acc2,
                                 list<bucket<kt> > buckets)
requires true == subset(acc1, acc2);
ensures true == subset(get_wraparound(acc1, buckets),
                       get_wraparound(acc2, buckets));
{
    switch(buckets) {
      case nil:
      case cons(h,t):
        acc_at_this_bucket_subset(acc1, acc2, h);
        advance_acc_subset(acc_at_this_bucket(acc1, h),
                           acc_at_this_bucket(acc2, h));
        subset_wraparound(advance_acc(acc_at_this_bucket(acc1, h)),
                          advance_acc(acc_at_this_bucket(acc2, h)),
                          t);

    }
  
}

lemma void buckets_ok_wraparound_bounded<kt>(list<bucket<kt> > buckets)
requires true == buckets_ok(buckets);
ensures true == forall(get_wraparound(nil, buckets),
                       (sup)((nat_lt)(length(buckets) - 1), snd));
{
  buckets_ok_wraparound_bounded_rec
  (get_wraparound(nil, buckets), buckets, length(buckets));
  subset_wraparound(nil, get_wraparound(nil, buckets), buckets);
  assert true == subset(get_wraparound(nil, buckets),
                        get_wraparound(get_wraparound(nil, buckets), buckets));
  subset_forall(get_wraparound(nil, buckets),
                get_wraparound(get_wraparound(nil, buckets), buckets),
                (sup)((nat_lt)(length(buckets) - 1), snd));
}

fixpoint list<pair<kt, nat> > get_crossing_chains_rec_fp<kt>(list<pair<kt, nat> > acc,
                                                             list<bucket<kt> > buckets,
                                                             int index) {
  switch(buckets) {
    case nil: return acc; //index must be -1 here
    case cons(h,t):
      return (index == 0) ?
      (advance_acc(acc_at_this_bucket(acc, h))) :
      (get_crossing_chains_rec_fp
       (advance_acc(acc_at_this_bucket(acc, h)), t, index - 1));
  }
}

fixpoint list<pair<kt, nat> > get_crossing_chains_fp<kt>(list<bucket<kt> > buckets,
                                                         int index) {
  return get_crossing_chains_rec_fp(get_wraparound(nil, buckets),
                                    buckets,
                                    index);
}

lemma void wraparound_is_last_crossing_chains<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets)
requires true;
ensures get_wraparound(acc, buckets) ==
        get_crossing_chains_rec_fp(acc, buckets, length(buckets) - 1);
{
  switch(buckets) {
    case nil: return;
    case cons(h,t):
      if (t == nil) {
      } else {
        wraparound_is_last_crossing_chains
        (advance_acc(acc_at_this_bucket(acc, h)), t);
        assert get_wraparound(acc, buckets) ==
               get_wraparound(advance_acc(acc_at_this_bucket(acc, h)), t);
        switch(t) {
          case nil:
          case cons(th,tt):
        }
        assert get_crossing_chains_rec_fp(acc, buckets,
                                          length(buckets) - 1) ==
               get_crossing_chains_rec_fp(advance_acc
                                          (acc_at_this_bucket(acc, h)),
                                          t, length(t) - 1);
      }
  }
}

lemma void advance_acc_append_commute<kt>(list<pair<kt, nat> > acc1,
                                          list<pair<kt, nat> > acc2)
requires true;
ensures advance_acc(append(acc1, acc2)) ==
        append(advance_acc(acc1), advance_acc(acc2));
{
  switch(acc1) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
    advance_acc_append_commute(t, acc2);
  }
}

lemma void append_acc_at_this_commute<kt>(list<pair<kt, nat> > acc0,
                                          list<pair<kt, nat> > acc,
                                          bucket<kt> b)
requires true;
ensures acc_at_this_bucket(append(acc0, acc), b) ==
        append(acc0, acc_at_this_bucket(acc, b));
{
  switch(b) {
    case bucket(chains):
      append_assoc(acc0, acc, chains);
  }
}

lemma void advance_acc_lower_limit<kt>(list<pair<kt, nat> > shrt,
                                       int uplim)
requires true == forall(shrt, (sup)((nat_lt)(uplim), snd));
ensures true == forall(advance_acc(shrt), (sup)((nat_lt)(uplim - 1), snd));
{
  switch(shrt) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
    advance_acc_lower_limit(t, uplim);
  }
}

lemma void advance_acc_lower_llimit<kt>(list<pair<kt, nat> > lng, int llim)
requires true == forall(lng, (sup)((nat_ge)(llim), snd));
ensures true == forall(advance_acc(lng), (sup)((nat_ge)(llim - 1), snd));
{
  switch(lng) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      advance_acc_lower_llimit(t, llim);
  }
}

lemma void upper_limit_nonpos_no_tail<kt>(list<pair<kt, nat> > shrt,
                                          int uplim)
requires uplim <= 0 &*&
         true == forall(shrt, (sup)((nat_lt)(uplim), snd));
ensures shrt == nil;
{
  switch(shrt) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
  }
}

lemma void short_chains_dont_matter<kt>(list<pair<kt, nat> > shrt,
                                        list<pair<kt, nat> > acc,
                                        list<bucket<kt> > buckets,
                                        int uplim, int index)
requires true == forall(shrt, (sup)((nat_lt)(uplim), snd)) &*&
         uplim <= index + 1 &*&
         index + 1 <= length(buckets);
ensures get_crossing_chains_rec_fp(append(shrt, acc), buckets, index) ==
        get_crossing_chains_rec_fp(acc, buckets, index);
{
  switch(buckets) {
    case nil:
      upper_limit_nonpos_no_tail(shrt, uplim);
    case cons(h,t):
      advance_acc_append_commute(shrt, acc_at_this_bucket(acc,h));
      append_acc_at_this_commute(shrt, acc, h);
      advance_acc_lower_limit(shrt, uplim);
      if (index == 0) {
        upper_limit_nonpos_no_tail(advance_acc(shrt), uplim - 1);
      } else {
        short_chains_dont_matter(advance_acc(shrt),
                                 advance_acc(acc_at_this_bucket(acc, h)),
                                 t, uplim - 1, index - 1);
      }
  }
}

lemma void buckets_ok_get_wraparound_idemp<kt>(list<bucket<kt> > buckets)
requires true == buckets_ok(buckets) &*& buckets != nil;
ensures get_wraparound(nil, buckets) ==
        get_wraparound(get_wraparound(nil, buckets), buckets);
{
  buckets_ok_wraparound_bounded(buckets);
  short_chains_dont_matter(get_wraparound(nil, buckets), nil,
                           buckets, length(buckets) - 1, length(buckets) - 1);
  wraparound_is_last_crossing_chains(nil, buckets);
  wraparound_is_last_crossing_chains(get_wraparound(nil, buckets), buckets);
}

fixpoint bool bucket_has_key_fp<kt>(kt k, bucket<kt> b) {
  switch(b) {
    case bucket(chains):
      return mem(k, map(fst, chains));
  }
}

lemma void no_crossing_chains_rec<kt>(list<pair<kt, nat> > acc,
                                      list<bucket<kt> > buckets,
                                      int index)
requires 0 <= index &*& index < length(buckets) &*&
         nth(index, buckets_get_chns_rec_fp(acc, buckets)) == 0;
ensures nil == get_crossing_chains_rec_fp(acc, buckets, index);
{
  switch(buckets) {
    case nil: return;
    case cons(bh,bt):
      if (0 == index) {
        assert get_crossing_chains_rec_fp(acc, buckets, index) ==
               advance_acc(acc_at_this_bucket(acc, bh));

        length_0_nil(advance_acc(acc_at_this_bucket(acc, bh)));
      } else {
        no_crossing_chains_rec(advance_acc(acc_at_this_bucket(acc, bh)),
                               bt, index - 1);
      }
  }
}

lemma void no_crossing_chains_here<kt>(list<bucket<kt> > buckets,
                                       int index)
requires 0 <= index &*& index < length(buckets) &*&
         nth(index, buckets_get_chns_fp(buckets)) == 0;
ensures nil == get_crossing_chains_fp(buckets, index);
{
  no_crossing_chains_rec(get_wraparound(nil, buckets), buckets, index);
}

lemma void this_bucket_still_no_key<kt>(list<pair<kt, nat> > acc, bucket<kt> bh, kt k)
requires false == mem(k, map(fst, acc)) &*&
         false == bucket_has_key_fp(k, bh);
ensures false == mem(k, map(fst, acc_at_this_bucket(acc, bh)));
{
  switch(bh) {
    case bucket(chains):
      map_append(fst, acc, chains);
  }
} //took 5m

lemma void advance_acc_still_no_key<kt>(list<pair<kt, nat> > acc, kt k)
requires false == mem(k, map(fst, acc));
ensures false == mem(k, map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
    advance_acc_still_no_key(t, k);
  }
}//took 4m

lemma void no_key_certainly_not_here<kt>(list<pair<kt, nat> > acc, kt k)
requires false == mem(k, map(fst, acc));
ensures get_current_key_fp(acc) != some(k);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              no_key_certainly_not_here(t, k);
          }
      }
  }
}//took 5m

lemma void some_bucket_contains_key_rec<kt>(list<pair<kt, nat> > acc, list<bucket<kt> > buckets, kt k)
requires true == mem(some(k), buckets_get_keys_rec_fp(acc, buckets)) &*&
         false == mem(k, map(fst, acc));
ensures true == exists(buckets, (bucket_has_key_fp)(k));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (bucket_has_key_fp(k, h)) {
      } else {
        this_bucket_still_no_key(acc, h, k);
        advance_acc_still_no_key(acc_at_this_bucket(acc, h), k);
        assert false == mem(k, map(fst, advance_acc(acc_at_this_bucket(acc, h))));
        no_key_certainly_not_here(acc_at_this_bucket(acc, h), k);
        assert get_current_key_fp(acc_at_this_bucket(acc, h)) != some(k);
        some_bucket_contains_key_rec(advance_acc(acc_at_this_bucket(acc, h)), t, k);
      }
  }
}

lemma void nozero_no_current_key<kt>(list<pair<kt, nat> > acc)
requires true;
ensures mem(zero, map(snd, acc)) ? get_current_key_fp(acc) != none :
        get_current_key_fp(acc) == none;
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(k,dist):
          switch(dist) {
            case zero:
            case succ(n):
              nozero_no_current_key(t);
          }
      }
  }
}

lemma void advance_acc_preserves_key<kt>(list<pair<kt, nat> > acc, kt key)
requires true == distinct(map(snd, acc)) &*& get_current_key_fp(acc) != some(key);
ensures mem(key, map(fst, acc)) == mem(key, map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(k,dst):
          switch(dst) {
            case zero:
              nozero_no_current_key(t);
              assert get_current_key_fp(t) == none;
              if (k == key) {
              } else {
                advance_acc_preserves_key(t, key);
              }
            case succ(n):
              assert get_current_key_fp(t) == get_current_key_fp(acc);
              if (k == key) {
              } else {
                advance_acc_preserves_key(t, key);
              }
          }
      }
  }
}

lemma void in_acc_then_in_the_map<kt>(list<bucket<kt> > buckets,
                                      kt k, int bound,
                                      list<pair<kt, nat> > acc)
requires true == mem(k, map(fst, acc)) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         false == mem(k, map(fst, get_wraparound(acc, buckets)));
ensures true == mem(some(k), buckets_get_keys_rec_fp(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      switch(h) {
        case bucket(chains):
          map_append(fst, acc, chains);
      }
      if (get_current_key_fp(atb) != some(k)) {
        advance_acc_preserves_key(atb, k);
        in_acc_then_in_the_map(t, k, bound, advance_acc(atb));
      }
    }
}

lemma void in_this_bucket_then_in_the_map<kt>(list<bucket<kt> > buckets,
                                              int n, kt k, int bound,
                                              list<pair<kt, nat> > acc)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         0 <= n &*& n < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(n, buckets)) &*&
         false == mem(k, map(fst, get_wraparound(acc, buckets)));
ensures true == mem(some(k), buckets_get_keys_rec_fp(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      switch(h) {
        case bucket(chains):
          map_append(fst, acc, chains);
      }
      if (n == 0) {
        if (get_current_key_fp(atb) != some(k)) {
          advance_acc_preserves_key(atb, k);
          in_acc_then_in_the_map(t, k, bound, advance_acc(atb));
        }
      } else {
        in_this_bucket_then_in_the_map(t, n - 1, k, bound, advance_acc(atb));
      }
  }
}//debugged VeriFast:Redux for 30m, not done yet

lemma void key_in_wraparound_then_key_in_a_bucket<kt>(list<bucket<kt> > buckets,
                                                      kt k,
                                                      list<pair<kt, nat> > acc)
requires true == mem(k, map(fst, get_wraparound(acc, buckets))) &*&
         false == mem(k, map(fst, acc));
ensures true == exists(buckets, (bucket_has_key_fp)(k));
{
  switch(buckets) {
    case nil:
    case cons(bh,bt):
      if (bucket_has_key_fp(k, bh)) {
      } else {
        this_bucket_still_no_key(acc, bh, k);
        advance_acc_still_no_key(acc_at_this_bucket(acc, bh), k);
        key_in_wraparound_then_key_in_a_bucket
        (bt, k, advance_acc(acc_at_this_bucket(acc, bh)));
      }
  }
}

lemma int key_index_in_acc<kt>(kt k, list<pair<kt, nat> > acc)
requires true == mem(k, map(fst, acc));
ensures 0 <= result &*& result < length(acc) &*&
        nth(result, acc) == pair(k, ?dist);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      if (fst(h) == k) return 0;
      int tail_index = key_index_in_acc(k, t);
      return 1 + tail_index;
  }
}

lemma void mem_advance_acc_swap<kt>(list<pair<kt, nat> > acc,
                                    kt k, nat d)
requires true;
ensures mem(pair(k, d), advance_acc(acc)) == mem(pair(k, succ(d)), acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(hk,hd):
          switch(hd) {
            case zero:
              mem_advance_acc_swap(t, k, d);
            case succ(hdn):
              if (h != pair(k, succ(d))) {
                mem_advance_acc_swap(t, k, d);
              }
          }
      }
  }
}

lemma void distinct_and_zero_this_is_the_key<kt>(list<pair<kt, nat> > acc,
                                                 kt k)
requires true == mem(pair(k,zero), acc) &*&
         true == distinct(map(snd, acc));
ensures get_current_key_fp(acc) == some(k);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,distance):
          switch(distance) {
            case zero:
              if (h != pair(k, zero)) {
                assert true == mem(pair(k,zero), t);
                mem_map(pair(k,zero), t, snd);
                assert true == mem(zero, map(snd, t));
                assert false;
              }
            case succ(n):
              distinct_and_zero_this_is_the_key(t, k);
          }
      }
  }
}

lemma void key_in_acc_then_in_all_keys<kt>(list<pair<kt, nat> > acc,
                                           list<bucket<kt> > buckets,
                                           pair<kt, nat> chain,
                                           int bound)
requires chain == pair(?k,?dist) &*&
         true == mem(chain, acc) &*&
         int_of_nat(dist) < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, bound);
ensures true == mem(some(k), buckets_get_keys_rec_fp(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(bh,bt):
      switch(bh) {
        case bucket(chains):
          switch(dist) {
            case zero:
              distinct_and_zero_this_is_the_key(acc_at_this_bucket(acc, bh), k);
            case succ(n):
              mem_advance_acc_swap(acc_at_this_bucket(acc, bh), k, n);
              key_in_acc_then_in_all_keys(advance_acc(acc_at_this_bucket(acc, bh)),
                                          bt, pair(k,n), bound);
          }
      }
  }
}

lemma void key_in_wraparound_then_in_bucket<kt>(list<bucket<kt> > buckets,
                                                kt k)
requires true == mem(k, map(fst, get_wraparound(nil, buckets))) &*&
         true == buckets_ok(buckets);
ensures true == mem(some(k), buckets_get_keys_fp(buckets));
{
  int pindex = key_index_in_acc(k, get_wraparound(nil, buckets));
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          forall_append(get_wraparound(nil, buckets), chains,
                        (sup)((nat_lt)(length(buckets)), snd));
      }
  }
  forall_mem(nth(pindex, get_wraparound(nil, buckets)),
             get_wraparound(nil, buckets),
             (sup)((nat_lt)(length(buckets)), snd));
  key_in_acc_then_in_all_keys(get_wraparound(nil, buckets), buckets,
                              nth(pindex, get_wraparound(nil, buckets)),
                              length(buckets));
}

lemma void buckets_keys_chns_same_len_rec<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets)
requires true;
ensures length(buckets_get_keys_rec_fp(acc, buckets)) == length(buckets) &*&
        length(buckets_get_chns_rec_fp(acc, buckets)) == length(buckets);
{
  switch(buckets) {
    case nil: return;
    case cons(h,t):
      buckets_keys_chns_same_len_rec(advance_acc(acc_at_this_bucket(acc, h)),
                                     t);
  }
}

lemma void buckets_keys_chns_same_len<kt>(list<bucket<kt> > buckets)
requires true;
ensures length(buckets_get_keys_fp(buckets)) == length(buckets) &*&
        length(buckets_get_chns_fp(buckets)) == length(buckets);
{
  buckets_keys_chns_same_len_rec(get_wraparound(nil, buckets), buckets);
}

lemma void next_cell_keeps_keys<kt>(list<pair<kt, nat> > acc, bucket<kt> b, kt k)
requires true == mem(k, map(fst, acc)) &*&
         get_current_key_fp(acc_at_this_bucket(acc, b)) != some(k) &*&
         true == distinct(map(snd, acc_at_this_bucket(acc, b)));
ensures true == mem(k, map(fst, advance_acc(acc_at_this_bucket(acc, b))));
{
  switch(b) {
    case bucket(chains):
      map_append(fst, acc, chains);
      advance_acc_preserves_key(acc_at_this_bucket(acc, b), k);
  }
}

lemma void next_i_cells_keep_keys<kt>(list<bucket<kt> > buckets,
                                      nat i,
                                      kt k,
                                      list<pair<kt, nat> > acc,
                                      int capacity)
requires true == up_to(succ(i),
                       (nthProp)(buckets_get_keys_rec_fp(acc, buckets),
                                 (neq)(some(k)))) &*&
         true == mem(k, map(fst, acc)) &*&
         true == buckets_ok_rec(acc, buckets, capacity) &*&
         int_of_nat(i) < length(buckets);
ensures true == mem(k, map(fst, get_crossing_chains_rec_fp(acc, buckets,
                                                           int_of_nat(i))));
{
  switch(buckets) {
    case nil:
    case cons(bh,bt):
      switch(i) {
        case zero:
          next_cell_keeps_keys(acc, bh, k);
        case succ(n):
          buckets_keys_chns_same_len_rec(acc, buckets);
          assert buckets_get_keys_rec_fp(acc, buckets) == cons(?bgkh, ?bgkt);
          up_to_nth_uncons(bgkh, bgkt, n, (neq)(some(k)));
          next_cell_keeps_keys(acc, bh, k);
          next_i_cells_keep_keys(bt, n, k,
                                 advance_acc(acc_at_this_bucket(acc, bh)),
                                 capacity);
      }
  }
}

lemma void bucket_has_then_acc_has_key<kt>(bucket<kt> b, list<pair<kt, nat> > acc, kt k)
requires true == bucket_has_key_fp(k, b);
ensures true == mem(k, map(fst, acc_at_this_bucket(acc, b)));
{
  switch(b) {
    case bucket(chains):
      map_append(fst, acc, chains);
  }
}//took 2m

lemma void crossing_chains_keep_key_hlp_inbound<kt>(list<bucket<kt> > buckets,
                                                    nat i,
                                                    int start,
                                                    int capacity,
                                                    kt k,
                                                    list<pair<kt, nat> > acc)
requires buckets != nil &*&
         true == up_to(succ(i),
                       (byLoopNthProp)(buckets_get_keys_rec_fp(acc, buckets),
                                       (neq)(some(k)),
                                       capacity,
                                       start)) &*&
         start + int_of_nat(i) < length(buckets) &*&
         length(buckets) <= capacity &*&
         0 <= start &*&
         true == buckets_ok_rec(acc, buckets, capacity) &*&
         start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures true == mem(k, map(fst,
                           get_crossing_chains_rec_fp(acc, buckets,
                                                      start + int_of_nat(i))));
{
  switch(buckets) {
    case nil: return;
    case cons(h,t):
      if (start == 0) {
        bucket_has_then_acc_has_key(h, acc, k);
        byLoopNthPropEqNthPropUpTo(succ(i), buckets_get_keys_rec_fp(acc, buckets),
                                   (neq)(some(k)), capacity);
        assert true == up_to(succ(i), (nthProp)(buckets_get_keys_rec_fp(acc, buckets),
                                                (neq)(some(k))));
        switch(i) {
          case zero:
            switch(h) {
              case bucket(chains):
                map_append(fst, acc, chains);
                advance_acc_preserves_key(acc_at_this_bucket(acc, h), k);
            }
          case succ(n):
            assert buckets_get_keys_rec_fp(acc, buckets) ==
                   cons(get_current_key_fp(acc_at_this_bucket(acc, h)),
                        buckets_get_keys_rec_fp(
                          advance_acc(acc_at_this_bucket(acc, h)), t));
            upToNthPropShift1(n, get_current_key_fp(acc_at_this_bucket(acc, h)),
                              buckets_get_keys_rec_fp(
                                advance_acc(acc_at_this_bucket(acc, h)), t),
                              (neq)(some(k)));
            assert true == up_to(n, (nthProp)(buckets_get_keys_rec_fp(advance_acc(acc_at_this_bucket(acc, h)), t), (neq)(some(k))));
            assert true == neq(some(k), get_current_key_fp(acc_at_this_bucket(acc, h)));
            assert true == mem(k, map(fst, acc_at_this_bucket(acc, h)));
            advance_acc_preserves_key(acc_at_this_bucket(acc, h), k);
            assert true == mem(k, map(fst, advance_acc(acc_at_this_bucket(acc, h))));
            assert int_of_nat(i) < length(buckets);
            assert int_of_nat(n) <= length(t);
            next_i_cells_keep_keys(t, n, k, advance_acc(acc_at_this_bucket(acc, h)), capacity);
        }

      } else {
        if (t == nil) {
          return;
        }
        less_than_neq(0, start + int_of_nat(i));
        upToByLoopNthPropShift1(
          succ(i),
          get_current_key_fp(acc_at_this_bucket(acc, h)),
          buckets_get_keys_rec_fp(
            advance_acc(acc_at_this_bucket(acc, h)), t),
          (neq)(some(k)),
          capacity,
          start);
        crossing_chains_keep_key_hlp_inbound(t, i, start - 1, capacity, k,
                                             advance_acc(
                                               acc_at_this_bucket(acc, h)));
      }
  }
}

lemma void crossing_chains_keep_key_inbound<kt>(list<bucket<kt> > buckets,
                                                nat i,
                                                int start,
                                                int capacity,
                                                kt k)
requires buckets != nil &*&
         true == up_to(succ(i),
                       (byLoopNthProp)(buckets_get_keys_fp(buckets),
                                       (neq)(some(k)),
                                       capacity,
                                       start)) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         0 <= start &*&
         start < length(buckets) &*&
         length(buckets) == capacity &*&
         true == buckets_ok(buckets) &*&
         start + int_of_nat(i) < capacity;
ensures true == mem(k, map(fst, get_crossing_chains_fp(buckets, start + int_of_nat(i))));
{
  crossing_chains_keep_key_hlp_inbound(buckets, i, start, capacity, k, get_wraparound(nil, buckets));
}

lemma void crossing_chains_keep_key<kt>(list<bucket<kt> > buckets,
                                        int i,
                                        int start,
                                        int capacity,
                                        kt k)
requires 0 <= i &*& i < capacity &*&
         0 <= start &*&
         start < length(buckets) &*&
         start + i - capacity + 1 <= capacity &*&
         buckets != nil &*&
         true == buckets_ok(buckets) &*&
         length(buckets) == capacity &*&
         true == up_to(nat_of_int(i+1),
                       (byLoopNthProp)(buckets_get_keys_fp(buckets),
                                       (neq)(some(k)),
                                       capacity,
                                       start)) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures true == mem(k, map(fst, get_crossing_chains_fp(buckets, loop_fp(start + i, capacity))));
{
  if (capacity <= start + i) {
    buckets_keys_chns_same_len(buckets);
    break_down_up_to_by_loop(buckets_get_keys_fp(buckets),
                             i+1, start, capacity, (neq)(some(k)));
    crossing_chains_keep_key_inbound(buckets,
                                     nat_of_int(capacity - start - 1),
                                     start, capacity, k);
    wraparound_is_last_crossing_chains
    (get_wraparound(nil, buckets), buckets);
    assert get_wraparound(get_wraparound(nil, buckets), buckets) ==
           get_crossing_chains_fp(buckets, length(buckets)-1);
    assert true == mem(k, map(fst,
                              get_crossing_chains_fp
                              (buckets,
                               start +
                               int_of_nat(nat_of_int(capacity -
                                                     start - 1)))));
    assert true == mem(k, map(fst, get_crossing_chains_fp
                              (buckets, capacity - 1)));
    buckets_ok_get_wraparound_idemp(buckets);

    assert get_wraparound(nil, buckets) ==
           get_wraparound(get_wraparound(nil, buckets), buckets);
    assert get_wraparound(nil, buckets) ==
           get_crossing_chains_fp(buckets, capacity - 1);

    assert true == mem(k, map(fst, get_crossing_chains_fp(buckets,
                                                          capacity - 1)));
    assert true == mem(k, map(fst, get_wraparound
                              (get_wraparound(nil, buckets),
                               buckets)));

    assert true == mem(k, map(fst, get_wraparound(nil, buckets)));
    next_i_cells_keep_keys(buckets, nat_of_int(start + i - capacity),
                           k, get_wraparound(nil, buckets), capacity);
    loop_injection(start + i - capacity, capacity);
    loop_bijection(start + i - capacity, capacity);
    assert loop_fp(start + i, capacity) == (start + i - capacity);
  } else {
    crossing_chains_keep_key_inbound(buckets, nat_of_int(i),
                                     start, capacity, k);
    loop_bijection(start + i, capacity);
  }
}

fixpoint list<int> add_partial_chain_rec_fp(list<int> chain_cnts,
                                            int start,
                                            int len) {
  switch(chain_cnts) {
    case nil:
      return nil;
    case cons(h,t):
      return ((start == 0)             ?
              ((len == 0) ? cons(h, t) :
               cons(h+1, add_partial_chain_rec_fp(t, 0, len-1))) :
              cons(h,add_partial_chain_rec_fp(t, start-1, len)));
  }
}

fixpoint list<int> add_partial_chain_fp(int start,
                                        int len,
                                        list<int> chain_cnts) {
  return ((length(chain_cnts) < start + len) ?
          add_partial_chain_rec_fp(
            add_partial_chain_rec_fp(chain_cnts, start, len),
            0,
            len + start - length(chain_cnts)) :
          add_partial_chain_rec_fp(chain_cnts, start, len));
}

fixpoint nat chain_with_key_fp<kt>(list<pair<kt,nat> > chains, kt k) {
  switch(chains) {
    case nil: return zero;
    case cons(h,t):
      return switch(h) {
        case pair(key,len):
          return (key == k) ? len :
          chain_with_key_fp(t, k);
      };
  }
}

fixpoint nat bucket_get_chain_fp<kt>(bucket<kt> b, kt k) {
  switch(b) {
    case bucket(chains):
      return chain_with_key_fp(chains, k);
  }
}

fixpoint int buckets_get_chain_fp<kt>(list<bucket<kt> > buckets,
                                      kt k,
                                      int start) {
  return int_of_nat(bucket_get_chain_fp(nth(start, buckets), k));
}

fixpoint list<int> rem_partial_chain_rec_fp(list<int> chain_cnts,
                                            int start,
                                            int len) {
  switch(chain_cnts) {
    case nil:
      return nil;
    case cons(h,t):
      return ((start == 0)             ?
              ((len == 0) ? cons(h, t) :
               cons(h-1, rem_partial_chain_rec_fp(t, 0, len-1))) :
              cons(h, rem_partial_chain_rec_fp(t, start-1, len)));
  }
}

fixpoint list<int> rem_partial_chain_fp(int start,
                                        int len,
                                        list<int> chain_cnts) {
  return ((length(chain_cnts) < start + len) ?
          rem_partial_chain_rec_fp(
            rem_partial_chain_rec_fp(chain_cnts, start, len),
            0,
            len + start - length(chain_cnts)) :
          rem_partial_chain_rec_fp(chain_cnts, start, len));
}

//<---- rem_partial_chain_symmetric_lemmas start here
lemma void advance_acc_forget_rem_zero_chain<kt>(list<pair<kt, nat> > acc, kt k)
requires true;
ensures advance_acc(remove(pair(k, zero), acc)) ==
        advance_acc(acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      advance_acc_forget_rem_zero_chain(t, k);
  }
}

lemma void composed_advance_acc_forget_rem_zero_chain<kt>(list<pair<kt, nat> > acc, list<pair<kt, nat> > chains, kt k)
requires true;
ensures advance_acc(append(acc, remove(pair(k, zero),
                                       chains))) ==
        advance_acc(append(acc, chains));
{
  switch(acc) {
    case nil:
      advance_acc_forget_rem_zero_chain(chains, k);
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      composed_advance_acc_forget_rem_zero_chain(
        t, chains, k);
  }
}

lemma void rem_no_partial_chain_rec(list<int> chns)
requires true;
ensures rem_partial_chain_rec_fp(chns, 0, 0) == chns;
{
  switch(chns) {
    case nil:
    case cons(h,t):
  }
}

lemma void advance_acc_remove_swap<kt>(list<pair<kt, nat> > acc, kt k, nat n)
requires true;
ensures advance_acc(remove(pair(k,succ(n)), acc)) ==
        remove(pair(k,n), advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(d):
              if (key == k && d == n) return;
          }
          advance_acc_remove_swap(t, k, n);
      }
  }
}

lemma void composed_advance_acc_remove_swap<kt>(list<pair<kt, nat> > acc,
                                                list<pair<kt, nat> > chains,
                                                kt k, nat n)
requires true;
ensures advance_acc(remove(pair(k,succ(n)), acc)) ==
        remove(pair(k,n), advance_acc(acc));
{
  switch(acc) {
    case nil:
      advance_acc_remove_swap(chains, k, n);
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(d):
          }
          composed_advance_acc_remove_swap(t, chains, k, n);
      }
  }
}


lemma void advance_acc_removes_zero<kt>(list<pair<kt, nat> > acc, kt k)
requires true;
ensures advance_acc(remove(pair(k, zero), acc)) == advance_acc(acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(x):
          }
      }
    if (h != pair(k, zero)) advance_acc_removes_zero(t, k);
  }
}


lemma void remove_advance_acc_swap<kt>(list<pair<kt, nat> > acc, kt k, nat n)
requires true;
ensures remove(pair(k, n), advance_acc(acc)) ==
        advance_acc(remove(pair(k, succ(n)), acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(x):
          }
      }
      if (h != pair(k, succ(n))) remove_advance_acc_swap(t, k, n);
  }
}

lemma void advance_acc_multiset_eq<kt>(list<pair<kt, nat> > acc1,
                                       list<pair<kt, nat> > acc2)
requires true == multiset_eq(acc1, acc2);
ensures true == multiset_eq(advance_acc(acc1), advance_acc(acc2));
{
  switch(acc1) {
    case nil:
    case cons(h,t):
      advance_acc_multiset_eq(t, remove(h, acc2));
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
              advance_acc_removes_zero(acc2, key);
            case succ(n):
              mem_advance_acc_swap(acc2, key, n);
              remove_advance_acc_swap(acc2, key, n);
          }
      }
  }
}

lemma void remove_pair_from_acc_wraparound<kt>(list<pair<kt, nat> > acc1,
                                               list<pair<kt, nat> > acc2,
                                               list<bucket<kt> > buckets,
                                               kt k, int dist)
requires true == multiset_eq(acc1, remove(pair(k, nat_of_int(dist)),
                                          acc2)) &*&
         length(buckets) <= dist &*&
         true == mem(pair(k, nat_of_int(dist)), acc2);
ensures true == multiset_eq(get_wraparound(acc1, buckets),
                            remove(pair(k, nat_of_int(dist - length(buckets))),
                                   get_wraparound(acc2, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          remove_append_swap(pair(k, nat_of_int(dist)), acc2, chains);
          multiset_eq_append_both(acc1,
                                  remove(pair(k, nat_of_int(dist)), acc2),
                                  chains);
          assert true == multiset_eq(atb1, remove(pair(k, nat_of_int(dist)),
                                                  atb2));
          advance_acc_multiset_eq(atb1, remove(pair(k, nat_of_int(dist)),
                                               atb2));
          assert true == multiset_eq(advance_acc(atb1),
                                     advance_acc(remove(pair(k, nat_of_int(dist)),
                                                        atb2)));
          advance_acc_remove_swap(atb2, k, nat_of_int(dist - 1));
          mem_advance_acc_swap(atb2, k, nat_of_int(dist - 1));
          remove_pair_from_acc_wraparound(advance_acc(atb1),
                                          advance_acc(atb2),
                                          t, k, dist - 1);
      }
  }
}

lemma void nonmem_not_this_key<kt>(list<pair<kt, nat> > acc, kt k)
requires false == mem(k, map(fst, acc));
ensures true == forall(acc, (not_this_key_pair_fp)(k));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      nonmem_not_this_key(t, k);
  }
}

lemma void not_this_key_nonmem<kt>(list<pair<kt, nat> > acc, kt k)
requires true == forall(acc, (not_this_key_pair_fp)(k));
ensures false == mem(k, map(fst, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      not_this_key_nonmem(t, k);
  }
}

lemma void no_key_in_acc_filter_no_effect<kt>(list<pair<kt, nat> > acc, kt k)
requires false == mem(k, map(fst, acc));
ensures acc == filter((not_this_key_pair_fp)(k), acc);
{
  nonmem_not_this_key(acc, k);
  filter_forall((not_this_key_pair_fp)(k), acc);
}

lemma void buckets_distinct_all_keys_breakdown<kt>(list<pair<kt, nat> > chains,
                                                   list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(cons(bucket(chains), buckets)));
ensures true == distinct(map(fst, chains)) &*&
        true == distinct(buckets_all_keys_fp(buckets)) &*&
        true == disjoint(map(fst, chains),
                         buckets_all_keys_fp(buckets)) &*&
        true == msubset(map(fst, chains),
                        buckets_all_keys_fp(cons(bucket(chains), buckets))) &*&
        true == msubset(buckets_all_keys_fp(buckets),
                        buckets_all_keys_fp(cons(bucket(chains), buckets)));
{
  distinct_unappend(map(fst, chains),
                    buckets_all_keys_fp(buckets));
  disjoint_comm(map(fst, chains),
                buckets_all_keys_fp(buckets));
  msubset_append(map(fst, chains), buckets_all_keys_fp(buckets));
}//took 3m

lemma void key_unique_filter_remove<kt>(kt k, list<pair<kt, nat> > acc)
requires true == mem(k, map(fst, acc)) &*&
         false == mem(k, remove(k, map(fst, acc)));
ensures filter((not_this_key_pair_fp)(k), acc) ==
        remove(pair(k, chain_with_key_fp(acc, k)), acc) &*&
        length(filter((not_this_key_pair_fp)(k), acc)) + 1 ==
        length(acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          if (k == key) {
            no_key_in_acc_filter_no_effect(t, k);
          } else {
            key_unique_filter_remove(k, t);
          }
      }
  }
}//took 3m

lemma void append_void_acc_same_chain_with_key<kt>(kt k, list<pair<kt, nat> > acc,
                                                   list<pair<kt, nat> > chains)
requires false == mem(k, map(fst, acc));
ensures chain_with_key_fp(append(acc, chains), k) ==
        chain_with_key_fp(chains, k);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
      }
      append_void_acc_same_chain_with_key(k, t, chains);
  }
}//took 2m

lemma void buckets_remove_nonexistent_key<kt>(list<bucket<kt> > buckets, kt k)
requires false == mem(k, buckets_all_keys_fp(buckets));
ensures buckets_remove_key_fp(buckets, k) == buckets;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          no_key_in_acc_filter_no_effect(chains, k);
          buckets_remove_nonexistent_key(t, k);
      }
  }
}//took 3m

lemma void distinct_key_here_remove_only_here<kt>(kt k,
                                                  list<pair<kt, nat> > chains,
                                                  list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(cons(bucket(chains), buckets))) &*&
         true == bucket_has_key_fp(k, bucket(chains));
ensures buckets_remove_key_fp(cons(bucket(chains), buckets), k) ==
        cons(bucket(filter((not_this_key_pair_fp)(k), chains)),
             buckets);
{
  buckets_distinct_all_keys_breakdown(chains, buckets);
  disjoint_mem(map(fst, chains), buckets_all_keys_fp(buckets), k);
  buckets_remove_nonexistent_key(buckets, k);
}//took 3m

lemma void bucket_has_key_mem_all_keys<kt>(kt k, int start,
                                           list<bucket<kt> > buckets)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures true == mem(k, buckets_all_keys_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
          } else {
            bucket_has_key_mem_all_keys(k, start - 1, t);
          }
      }
  }
}

lemma void distinct_key_in_following_not_in_the_first_bucket<kt>(kt k, int start,
                                                                 list<pair<kt, nat> > chains,
                                                                 list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(cons(bucket(chains), buckets))) &*&
         0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures false == mem(k, map(fst, chains));
{
  bucket_has_key_mem_all_keys(k, start, buckets);
  distinct_unappend(map(fst, chains), buckets_all_keys_fp(buckets));
  disjoint_mem(buckets_all_keys_fp(buckets), map(fst, chains), k);
}

lemma void distinct_key_in_here_not_in_the_following<kt>(kt k,
                                                         list<pair<kt, nat> > chains,
                                                         list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(cons(bucket(chains), buckets))) &*&
         true == bucket_has_key_fp(k, bucket(chains));
ensures false == mem(k, buckets_all_keys_fp(buckets));
{
  distinct_unappend(map(fst, chains), buckets_all_keys_fp(buckets));
  disjoint_mem(buckets_all_keys_fp(buckets), map(fst, chains), k);
}


lemma void acc_remove_chain_get_chns<kt>(kt k, int dist,
                                         list<pair<kt, nat> > acc,
                                         list<bucket<kt> > buckets)
requires true == mem(pair(k, nat_of_int(dist)), acc) &*&
         0 <= dist;
ensures buckets_get_chns_rec_fp
        (remove(pair(k, nat_of_int(dist)), acc),
         buckets) ==
        rem_partial_chain_rec_fp
        (buckets_get_chns_rec_fp(acc, buckets),
         0, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = acc_at_this_bucket(
            remove(pair(k, nat_of_int(dist)), acc), h);
          remove_append_swap(pair(k, nat_of_int(dist)), acc, chains);
          assert new_atb == remove(pair(k, nat_of_int(dist)), atb);
          assert length(atb) - 1 == length(new_atb);
          if (dist == 0) {
            advance_acc_forget_rem_zero_chain(atb, k);
            assert advance_acc(atb) == advance_acc(new_atb);
          } else {
            nat m = nat_of_int(dist - 1);
            assert succ(m) == nat_of_int(dist);
            advance_acc_remove_swap(atb, k, m);
            mem_advance_acc_swap(atb, k, m);
            assert advance_acc(new_atb) ==
                   remove(pair(k, nat_of_int(dist - 1)), advance_acc(atb));
            acc_remove_chain_get_chns(k, dist - 1, advance_acc(atb), t);
          }
      }
  }
}

lemma void acc_eq_get_chns_eq<kt>(list<pair<kt, nat> > acc1,
                                  list<pair<kt, nat> > acc2,
                                  list<bucket<kt> > buckets)
requires true == multiset_eq(acc1, acc2);
ensures buckets_get_chns_rec_fp(acc1, buckets) ==
        buckets_get_chns_rec_fp(acc2, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          multiset_eq_append_both(acc1, acc2, chains);
          advance_acc_multiset_eq(atb1, atb2);
          multiset_eq_same_len(advance_acc(atb1), advance_acc(atb2));
          acc_eq_get_chns_eq(advance_acc(atb1), advance_acc(atb2), t);
      }
  }
}

lemma void advance_acc_shortens_chain<kt>(list<pair<kt, nat> > acc,
                                          kt k, nat dst)
requires true == mem(pair(k,dst), acc) &*& dst == succ(?n);
ensures true == mem(pair(k,n), advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
              advance_acc_shortens_chain(t, k, dst);
            case succ(m):
              if (h == pair(k,dst)) return;
              advance_acc_shortens_chain(t, k, dst);
          }
      }
  }
}

lemma void buckets_remove_key_same_len<kt>(list<bucket<kt> > buckets, kt k)
requires true;
ensures length(buckets_remove_key_fp(buckets, k)) == length(buckets);
{
  switch(buckets) {
    case nil:
    case cons(bh,bt):
      switch(bh) {
        case bucket(chains):
          buckets_remove_key_same_len(bt,k);
      }
  }
}//took 2m

lemma void keep_short_same_len<kt>(list<bucket<kt> > buckets)
requires true;
ensures length(buckets) == length(keep_short_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
      }
      keep_short_same_len(t);
  }
}//took 1m

lemma void keep_short_remove_key_swap<kt>(list<bucket<kt> > buckets, kt k)
requires true;
ensures keep_short_fp(buckets_remove_key_fp(buckets, k)) ==
        buckets_remove_key_fp(keep_short_fp(buckets), k);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          keep_short_remove_key_swap(t, k);
          filter_filter_swap((sup)((nat_lt)(length(buckets)), snd),
                             (not_this_key_pair_fp)(k),
                             chains);
          buckets_remove_key_same_len(buckets, k);
          keep_short_same_len(buckets);
      }
  }
}//took 8m

lemma void buckets_rem_part_get_chns_norm_rec<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets,
                                                  kt k, int start, int dist,
                                                  int bound)
requires 0 <= start &*&
         0 <= dist &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         true == distinct(buckets_all_keys_fp(buckets));
ensures buckets_get_chns_rec_fp(acc, buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_rec_fp(buckets_get_chns_rec_fp(acc, buckets),
                                 start, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = acc_at_this_bucket(
            acc, bucket(filter((not_this_key_pair_fp)(k), chains)));
          if (start == 0) {
            assert new_atb == append(acc, filter((not_this_key_pair_fp)(k), chains));
            buckets_distinct_all_keys_breakdown(chains, t);
            distinct_unique(map(fst, chains), k);
            key_unique_filter_remove(k, chains);
            if (dist == 0) {
              composed_advance_acc_forget_rem_zero_chain(
                acc, chains, k);
              assert advance_acc(atb) == advance_acc(new_atb);
              switch(buckets_get_chns_rec_fp(advance_acc(atb), t)) {
                case nil:
                case cons(hhh,ttt):
              }
              assert rem_partial_chain_rec_fp
                     (buckets_get_chns_rec_fp(advance_acc(atb), t),
                      start, dist) ==
                     buckets_get_chns_rec_fp(advance_acc(atb), t);
              distinct_key_here_remove_only_here(k, chains, t);
            } else {
              nat m = nat_of_int(dist - 1);
              assert succ(m) == nat_of_int(dist);
              multiset_eq_refl(acc);
              multiset_eq_refl(remove(pair(k, nat_of_int(dist)), chains));
              multiset_eq_append(acc, acc,
                                 filter((not_this_key_pair_fp)(k), chains),
                                 remove(pair(k, nat_of_int(dist)), chains));
              multiset_remove_append_swap(pair(k, nat_of_int(dist)),
                                          acc, chains);
              multiset_eq_comm(remove(pair(k, nat_of_int(dist)), atb),
                               append(acc, remove(pair(k, nat_of_int(dist)),
                                                  chains)));
              multiset_eq_trans(new_atb,
                                append(acc, remove(pair(k, nat_of_int(dist)),
                                                   chains)),
                                remove(pair(k, nat_of_int(dist)), atb));
              assert true == multiset_eq(new_atb,
                                         remove(pair(k, nat_of_int(dist)),
                                                atb));
              advance_acc_multiset_eq(new_atb,
                                      remove(pair(k, nat_of_int(dist)),
                                             atb));
              advance_acc_remove_swap(atb, k, m);
              assert true == multiset_eq(advance_acc(new_atb),
                                         remove(pair(k, nat_of_int(dist-1)),
                                                advance_acc(atb)));
              acc_eq_get_chns_eq(advance_acc(new_atb),
                                 remove(pair(k, nat_of_int(dist - 1)),
                                        advance_acc(atb)),
                                 t);
              assert buckets_get_chns_rec_fp(advance_acc(new_atb), t) ==
                     buckets_get_chns_rec_fp(remove(pair(k, nat_of_int(dist-1)),
                                                         advance_acc(atb)),
                                                    t);
              mem_advance_acc_swap(atb, k, m);
              acc_remove_chain_get_chns(k, dist - 1, advance_acc(atb), t);
              advance_acc_shortens_chain(atb, k, nat_of_int(dist));
              multiset_eq_same_len(advance_acc(new_atb),
                                   remove(pair(k, nat_of_int(dist - 1)),
                                          advance_acc(atb)));
              disjoint_mem(map(fst, chains), buckets_all_keys_fp(t), k);
              buckets_remove_nonexistent_key(t, k);

            }
          } else {
            msubset_append(map(fst, chains), buckets_all_keys_fp(t));
            assert true == msubset(buckets_all_keys_fp(t),
                                   buckets_all_keys_fp(buckets));
            msubset_distinct(buckets_all_keys_fp(t),
                             buckets_all_keys_fp(buckets));
            assert start < length(buckets);
            assert start - 1 < length(t);
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1, chains, t);
            assert false == mem(k, map(fst, chains));
            buckets_rem_part_get_chns_norm_rec(advance_acc(atb),
                                               t, k, start - 1, dist,
                                               bound);
            no_key_in_acc_filter_no_effect(chains, k);
          }
      }
  }
}

lemma void buckets_rem_part_get_chns_norm_acc_has<kt>(list<pair<kt, nat> > acc,
                                                      list<bucket<kt> > buckets,
                                                      kt k, int start, int dist,
                                                      int bound)
requires 0 <= start &*& start + dist <= length(buckets) &*&
         0 <= dist &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         false == mem(k, map(fst, advance_acc(acc)));
ensures buckets_get_chns_rec_fp(acc, buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_rec_fp(buckets_get_chns_rec_fp(acc, buckets),
                                 start, dist);
{
  buckets_rem_part_get_chns_norm_rec(acc, buckets, k, start, dist, bound);
}

lemma void acc_rem_short_chain_same_wraparound<kt>(list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets,
                                                   kt k, int dist)
requires 0 <= dist &*& dist < length(buckets);
ensures get_wraparound(remove(pair(k, nat_of_int(dist)), acc), buckets) ==
        get_wraparound(acc, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (!mem(pair(k, nat_of_int(dist)), acc)) {
            remove_nonmem(pair(k, nat_of_int(dist)), acc);
            return;
          }
          remove_append_swap(pair(k, nat_of_int(dist)), acc, chains);
          if (dist == 0) {
            advance_acc_forget_rem_zero_chain(atb, k);
          } else {
            advance_acc_remove_swap(atb, k, nat_of_int(dist - 1));
            acc_rem_short_chain_same_wraparound(advance_acc(atb), t, k, dist - 1);
          }
      }
  }
}//took 5m

lemma void buckets_rem_short_chain_same_wraparound<kt>(list<pair<kt, nat> > acc,
                                                       list<bucket<kt> > buckets,
                                                       kt k,
                                                       int start,
                                                       int dist,
                                                       int capacity)
requires 0 <= start &*& start < length(buckets) &*&
         start + dist < length(buckets) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         0 <= dist &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         false == mem(k, map(fst, acc));
ensures get_wraparound(acc, buckets_remove_key_fp(buckets, k)) ==
        get_wraparound(acc, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = acc_at_this_bucket(
            acc, bucket(filter((not_this_key_pair_fp)(k), chains)));
          buckets_distinct_all_keys_breakdown(chains, t);
          if (start == 0) {
            distinct_key_in_here_not_in_the_following(k, chains, t);
            buckets_remove_nonexistent_key(t, k);
            distinct_unique(map(fst, chains), k);
            key_unique_filter_remove(k, chains);
            remove_append_swap(pair(k, nat_of_int(dist)), acc, chains);
            if (mem(pair(k, nat_of_int(dist)), acc)) {
              mem_map(pair(k, nat_of_int(dist)), acc, fst);
              assert false;
            }
            assert new_atb == remove(pair(k, nat_of_int(dist)), atb);
            if (dist == 0) {
              advance_acc_removes_zero(atb, k);
              assert get_wraparound(acc, buckets_remove_key_fp(buckets, k)) ==
                     get_wraparound(advance_acc(new_atb), t);
              assert advance_acc(new_atb) == advance_acc(atb);
              return;
            }
            acc_rem_short_chain_same_wraparound(advance_acc(atb),
                                                t, k, dist - 1);
            remove_advance_acc_swap(atb, k, nat_of_int(dist-1));
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            no_key_in_acc_filter_no_effect(chains, k);
            assert new_atb == atb;
            map_append(fst, acc, chains);
            advance_acc_still_no_key(atb, k);
            buckets_rem_short_chain_same_wraparound(advance_acc(atb), t,
                                                    k, start - 1, dist,
                                                    capacity);
          }
      }
  }
}

lemma void distinct_filter_out_chain<kt>(fixpoint (pair<kt,nat>,bool) f,
                                         list<pair<kt, nat> > acc,
                                         kt k, nat dst)
requires true == distinct(map(fst, acc)) &*&
         false == f(pair(k, dst)) &*&
         true == mem(pair(k, dst), acc);
ensures false == mem(k, map(fst, filter(f, acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          if (key == k) {
            distinct_map_identical_elems(fst, acc,
                                         pair(k, dst),
                                         pair(key, dist));
            assert dist == dst;
            nonmem_map_filter(fst, f, t, pair(k, zero));
            assert false == mem(k, map(fst, filter(f, t)));
            return;
          } else {
            distinct_filter_out_chain(f, t, k, dst);
          }
      }
  }
}//took 6m

lemma void bucket_get_chain_mem<kt>(list<pair<kt, nat> > chains, kt k)
requires true == bucket_has_key_fp(k, bucket(chains));
ensures true == mem(pair(k, bucket_get_chain_fp(bucket(chains), k)),
                    chains);
{
  switch(chains) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          if (key == k) {
            return;
          } else {
            bucket_get_chain_mem(t, k);
          }
      }
  }
}//took 2m

lemma void short_long_keys_msubset<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == msubset(buckets_all_keys_fp(keep_long_fp(buckets)),
                        buckets_all_keys_fp(buckets)) &*&
        true == msubset(buckets_all_keys_fp(keep_short_fp(buckets)),
                        buckets_all_keys_fp(buckets));
//true == multiset_eq(append (short, long keys), all keys)
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > lchains = filter((sup)((nat_ge)(length(buckets)),
                                                      snd),
                                                chains);
          list<pair<kt, nat> > schains = filter((sup)((nat_lt)(length(buckets)),
                                                      snd),
                                                chains);
          filter_msubset((sup)((nat_lt)(length(buckets)), snd), chains);
          filter_msubset((sup)((nat_ge)(length(buckets)), snd), chains);
          msubset_map(fst, lchains, chains);
          msubset_map(fst, schains, chains);
          short_long_keys_msubset(t);
          msubset_append_both(map(fst, lchains),
                              buckets_all_keys_fp(keep_long_fp(t)),
                              map(fst, chains),
                              buckets_all_keys_fp(t));
          msubset_append_both(map(fst, schains),
                              buckets_all_keys_fp(keep_short_fp(t)),
                              map(fst, chains),
                              buckets_all_keys_fp(t));
      }
  }
}

lemma void short_chain_does_not_make_to_long_bkts<kt>(list<bucket<kt> > buckets,
                                                      kt k, int start, int dist)
requires 0 <= start &*& start + dist < length(buckets) &*&
         0 <= dist &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == distinct(buckets_all_keys_fp(buckets));
ensures false == mem(k, buckets_all_keys_fp(keep_long_fp(buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          buckets_distinct_all_keys_breakdown(chains, t);
          if (start == 0) {
            distinct_key_in_here_not_in_the_following(k, chains, t);
            buckets_remove_nonexistent_key(t, k);
            bucket_get_chain_mem(chains, k);
            distinct_filter_out_chain((sup)((nat_ge)(length(buckets)), snd),
                                      chains,
                                      k, nat_of_int(dist));
            assert false == mem(k,
                                map(fst, filter((sup)((nat_ge)(length(buckets)), snd),
                                                chains)));
            assert false == mem(k, buckets_all_keys_fp(t));
            short_long_keys_msubset(t);
            msubset_subset(buckets_all_keys_fp(keep_long_fp(t)),
                           buckets_all_keys_fp(t));
            if (mem(k, buckets_all_keys_fp(keep_long_fp(t)))) {
              subset_mem_trans(buckets_all_keys_fp(keep_long_fp(t)),
                               buckets_all_keys_fp(t),
                               k);
            }
            assert false == mem(k, buckets_all_keys_fp(keep_long_fp(t)));
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            no_key_in_acc_filter_no_effect(chains, k);
            short_chain_does_not_make_to_long_bkts(t, k, start - 1, dist);
            nonmem_map_filter(fst, (sup)((nat_ge)(length(buckets)), snd),
                              chains, pair(k, zero));
          }

      }
  }
}//took 30m

lemma void keep_long_same_len<kt>(list<bucket<kt> > buckets)
requires true;
ensures length(buckets) == length(keep_long_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains) :
          keep_long_same_len(t);
      }
  }
}//took 2m

lemma void keep_long_indeed_long<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == buckets_long_fp(keep_long_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      keep_long_same_len(buckets);
      switch(h) {
        case bucket(chains):
          filter_forall((sup)((nat_ge)(length(buckets)), snd), chains);
          assert keep_long_fp(buckets) ==
                 cons(bucket(filter((sup)((nat_ge)(length(buckets)), snd), chains)),
                      keep_long_fp(t));
          assert true == forall(filter((sup)((nat_ge)(length(buckets)), snd), chains),
                                (sup)((nat_ge)(length(buckets)), snd));
          keep_long_indeed_long(t);
          assert true == buckets_long_fp(keep_long_fp(t));
          assert true == buckets_long_fp(cons(bucket(filter((sup)((nat_ge)(length(buckets)), snd), chains)),
                                              keep_long_fp(t)));
      }
  }
}

lemma void long_chains_advance_acc_same_keys<kt>(list<pair<kt, nat> > acc,
                                                 int lim)
requires 0 < lim &*&
         true == forall(acc, (sup)((nat_ge)(lim), snd));
ensures map(fst, acc) == map(fst, advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert false;
            case succ(n):
          }
      }
      long_chains_advance_acc_same_keys(t, lim);
  }
}//took 1m

lemma void long_buckets_all_keys_in_wraparound_rec<kt>(list<pair<kt, nat> > acc,
                                                       list<bucket<kt> > buckets)
requires true == buckets_long_fp(buckets) &*&
         true == forall(acc, (sup)((nat_ge)(length(buckets)), snd));
ensures true == multiset_eq(map(fst, get_wraparound(acc, buckets)),
                            append(map(fst, acc),
                                   buckets_all_keys_fp(buckets)));
{
  switch(buckets) {
    case nil:
      multiset_eq_refl(map(fst, acc));
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          map_append(fst, acc, chains);
          forall_append(acc, chains,
                        (sup)((nat_ge)(length(buckets)), snd));
          advance_acc_lower_llimit(atb, length(buckets));
          long_chains_advance_acc_same_keys(atb, length(buckets));
          long_buckets_all_keys_in_wraparound_rec(advance_acc(atb), t);
          assert true == multiset_eq(map(fst, get_wraparound(acc, buckets)),
                                     append(map(fst, advance_acc(atb)),
                                            buckets_all_keys_fp(t)));
          append_append_assoc(map(fst, acc), map(fst, chains),
                              buckets_all_keys_fp(t));
      }
  }
}//took 17m

lemma void long_buckets_all_keys_in_wraparound<kt>(list<bucket<kt> > buckets)
requires true == buckets_long_fp(buckets);
ensures true == multiset_eq(map(fst, get_wraparound(nil, buckets)),
                            buckets_all_keys_fp(buckets));
{
  long_buckets_all_keys_in_wraparound_rec(nil, buckets);
}//took 3m

lemma void filter_zero_lower_limit_no_effect<kt>(list<pair<kt, nat> > acc)
requires true;
ensures filter((sup)((nat_ge)(0), snd), acc) == acc;
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
          filter_zero_lower_limit_no_effect(t);
      }
  }
}

lemma void advance_acc_filter_keep_long_swap<kt>(list<pair<kt, nat> > acc,
                                                 int cutoff)
requires 0 < cutoff;
ensures advance_acc(filter((sup)((nat_ge)(cutoff), snd), acc)) ==
        filter((sup)((nat_ge)(cutoff - 1), snd), advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
          advance_acc_filter_keep_long_swap(t, cutoff);
      }
  }
}

lemma void filter_acc_keep_wraparound<kt>(list<pair<kt, nat> > acc,
                                          list<bucket<kt> > buckets)
requires true;
ensures get_wraparound(acc, buckets) ==
        get_wraparound(filter((sup)((nat_ge)(length(buckets)), snd), acc), buckets);
{
  switch(buckets) {
    case nil:
      filter_zero_lower_limit_no_effect(acc);
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > f_atb =
          append(filter((sup)((nat_ge)(length(buckets)), snd), acc), chains);
          list<pair<kt, nat> > filt_all_atb =
          append(filter((sup)((nat_ge)(length(buckets)), snd), acc),
                 filter((sup)((nat_ge)(length(buckets)), snd), chains));
          filter_append_idemp(acc, chains, (sup)((nat_ge)(length(buckets)), snd));
          filter_append_idemp(filter((sup)((nat_ge)(length(buckets)), snd), acc),
                              chains,
                              (sup)((nat_ge)(length(buckets)), snd));
          filter_forall((sup)((nat_ge)(length(buckets)), snd), acc);
          filter_forall((sup)((nat_ge)(length(buckets)), snd),
                        filter((sup)((nat_ge)(length(buckets)), snd), acc));
          assert filter((sup)((nat_ge)(length(buckets)), snd), atb) ==
                 filt_all_atb;
          assert filt_all_atb ==
                 append(filter((sup)((nat_ge)(length(buckets)), snd), filter((sup)((nat_ge)(length(buckets)), snd), acc)),
                        filter((sup)((nat_ge)(length(buckets)), snd), chains));
          assert filter((sup)((nat_ge)(length(buckets)), snd), filter((sup)((nat_ge)(length(buckets)), snd), acc)) ==
                 filter((sup)((nat_ge)(length(buckets)), snd), acc);
          assert filter((sup)((nat_ge)(length(buckets)), snd), f_atb) ==
                 filt_all_atb;
          advance_acc_filter_keep_long_swap(atb, length(buckets));
          advance_acc_filter_keep_long_swap(f_atb, length(buckets));
          assert filter((sup)((nat_ge)(length(t)), snd), advance_acc(atb)) ==
                 advance_acc(filt_all_atb);
          assert filter((sup)((nat_ge)(length(t)), snd), advance_acc(f_atb)) ==
                 advance_acc(filt_all_atb);
          filter_acc_keep_wraparound(advance_acc(atb), t);
          filter_acc_keep_wraparound(advance_acc(f_atb), t);
      }
  }
}//took 30m

lemma void keep_long_same_wraparound<kt>(list<pair<kt, nat> > acc,
                                         list<bucket<kt> > buckets)
requires true;
ensures get_wraparound(acc, keep_long_fp(buckets)) ==
        get_wraparound(acc, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > filter_acc =
      filter((sup)((nat_ge)(length(buckets)), snd), acc);
      filter_acc_keep_wraparound(acc, buckets);
      filter_acc_keep_wraparound(acc, keep_long_fp(buckets));
      keep_long_same_len(buckets);
      filter_forall((sup)((nat_ge)(length(buckets)), snd), acc);
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(filter_acc, h);
          list<pair<kt, nat> > long_atb =
          append(filter_acc, filter((sup)((nat_ge)(length(buckets)), snd),
                                    chains));
          filter_append_idemp(filter_acc, chains,
                              (sup)((nat_ge)(length(buckets)), snd));
          filter_forall((sup)((nat_ge)(length(buckets)), snd), filter_acc);
          assert long_atb == filter((sup)((nat_ge)(length(buckets)), snd), atb);
          filter_acc_keep_wraparound(advance_acc(atb), t);
          advance_acc_filter_keep_long_swap(atb, length(buckets));
          keep_long_same_wraparound(advance_acc(long_atb), t);
      }
  }
}

lemma void short_chain_does_not_wraparound<kt>(list<bucket<kt> > buckets,
                                               kt k, int start, int dist)
requires 0 <= start &*& start + dist < length(buckets) &*&
         0 <= dist &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == buckets_ok(buckets);
ensures false == mem(k, map(fst, get_wraparound(nil, buckets)));
{
  list<bucket<kt> > high = keep_long_fp(buckets);
  short_chain_does_not_make_to_long_bkts(buckets, k, start, dist);
  assert false == mem(k, buckets_all_keys_fp(high));
  keep_long_indeed_long(buckets);
  long_buckets_all_keys_in_wraparound(high);
  multiset_eq_comm(map(fst, get_wraparound(nil, high)),
                   buckets_all_keys_fp(high));
  multiset_eq_mem(k, buckets_all_keys_fp(high),
                  map(fst, get_wraparound(nil, high)));
  assert false == mem(k, map(fst, get_wraparound(nil, high)));
  keep_long_same_wraparound(nil, buckets);
  assert false == mem(k, map(fst, get_wraparound(nil, buckets)));
}//took 25m

lemma void buckets_rem_same_len<kt>(list<bucket<kt> > buckets, kt k)
requires true;
ensures length(buckets) == length(buckets_remove_key_fp(buckets, k));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          buckets_rem_same_len(t, k);
      }
  }
}//took 1m

lemma void buckets_rem_part_get_chns_norm<kt>(list<bucket<kt> > buckets,
                                              kt k, int start, int dist)
requires start + dist < length(buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == buckets_ok(buckets);
ensures buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  buckets_rem_short_chain_same_wraparound(nil, buckets,
                                          k, start, dist,
                                          length(buckets));
  short_chain_does_not_wraparound(buckets, k, start, dist);
  assert false == mem(k, map(fst, get_wraparound(nil, buckets)));
  buckets_rem_part_get_chns_norm_rec(get_wraparound(nil, buckets),
                                     buckets, k, start, dist,
                                     length(buckets));
  buckets_keys_chns_same_len(buckets);
  buckets_rem_same_len(buckets, k);
  buckets_keys_chns_same_len(buckets_remove_key_fp(buckets, k));
}

lemma void buckets_rem_wraparound_eq_rem<kt>(list<pair<kt, nat> > acc,
                                             list<bucket<kt> > buckets,
                                             kt k, int start, int dist)
requires length(buckets) <= start + dist &*&
         0 <= dist &*&
         0 <= start &*& start < length(buckets) &*&
         false == mem(k, map(fst, acc)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) ==
         nat_of_int(dist);
ensures true == multiset_eq
        (get_wraparound(acc, buckets_remove_key_fp(buckets, k)),
         remove(pair(k, nat_of_int(dist + start - length(buckets))),
                get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          buckets_distinct_all_keys_breakdown(chains, t);
          if (start == 0) {
            list<pair<kt, nat> > new_atb =
            acc_at_this_bucket(acc, bucket(filter((not_this_key_pair_fp)(k),
                                                  chains)));
            assert get_wraparound(acc, buckets_remove_key_fp(buckets, k)) ==
                   get_wraparound(advance_acc(new_atb),
                                  buckets_remove_key_fp(t, k));
            assert true == mem(k, map(fst, chains));
            disjoint_mem(map(fst, chains), buckets_all_keys_fp(t), k);
            buckets_remove_nonexistent_key(t, k);

            no_key_in_acc_filter_no_effect(acc, k);
            filter_append_idemp(acc, chains, (not_this_key_pair_fp)(k));
            map_append(fst, acc, chains);
            remove_append_swap(k, map(fst, acc), map(fst, chains));
            distinct_unique(map(fst, chains), k);
            key_unique_filter_remove(k, append(acc, chains));
            append_void_acc_same_chain_with_key(k, acc, chains);
            multiset_eq_refl(new_atb);
            if (dist == 0) {
              advance_acc_removes_zero(atb, k);
            } else {
              advance_acc_multiset_eq(new_atb,
                                      remove(pair(k, nat_of_int(dist)), atb));
              advance_acc_remove_swap(atb, k, nat_of_int(dist-1));
              assert succ(nat_of_int(dist-1)) == nat_of_int(dist);
              bucket_get_chain_mem(chains, k);
              assert true == mem(pair(k, nat_of_int(dist)), chains);
              assert true == mem(pair(k, nat_of_int(dist)), atb);
              mem_advance_acc_swap(atb, k, nat_of_int(dist - 1));
              assert true == mem(pair(k, nat_of_int(dist - 1)), advance_acc(atb));
              remove_pair_from_acc_wraparound(advance_acc(new_atb),
                                              advance_acc(atb),
                                              t, k, dist - 1);
            }
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            map_append(fst, acc, chains);
            advance_acc_still_no_key(atb, k);
            buckets_rem_wraparound_eq_rem(advance_acc(atb), t,
                                          k, start - 1, dist);
            no_key_in_acc_filter_no_effect(chains, k);
          }
      }
  }
  
}

lemma void buckets_rem_chain_lim_wraparound_rem_zero_chain<kt>(list<pair<kt, nat> > acc,
                                                               list<bucket<kt> > buckets,
                                                               kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         false == mem(k, map(fst, acc)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) ==
         nat_of_int(length(buckets) - start);
ensures true == multiset_eq
        (get_wraparound(acc, buckets_remove_key_fp(buckets, k)),
         remove(pair(k, zero),
                get_wraparound(acc, buckets)));
{
  buckets_rem_wraparound_eq_rem(acc, buckets, k, start,
                                length(buckets) - start);
}

lemma void acc_lacking_zero_chain_same_chns<kt>(list<pair<kt, nat> > acc1,
                                                list<pair<kt, nat> > acc2,
                                                list<bucket<kt> > buckets,
                                                kt k)
requires true == multiset_eq(acc1, remove(pair(k, zero), acc2)) &*&
         buckets != nil;
ensures buckets_get_chns_rec_fp(acc1, buckets) ==
        buckets_get_chns_rec_fp(acc2, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          if (mem(pair(k, zero), acc2)) {
            remove_append_swap(pair(k, zero), acc2, chains);
            assert remove(pair(k, zero), atb2) ==
                   append(remove(pair(k, zero), acc2), chains);
            multiset_eq_append_both(acc1, remove(pair(k, zero), acc2), chains);
            assert true == multiset_eq(atb1, remove(pair(k, zero), atb2));
            advance_acc_multiset_eq(atb1, remove(pair(k, zero), atb2));
            advance_acc_forget_rem_zero_chain(atb2, k);
            assert true == multiset_eq(advance_acc(atb1), advance_acc(atb2));
          } else {
            remove_nonmem(pair(k, zero), acc2);
            assert remove(pair(k, zero), acc2) == acc2;
            multiset_eq_append_both(acc1, acc2, chains);
            advance_acc_multiset_eq(atb1, atb2);
          }
          assert true == multiset_eq(advance_acc(atb1),
                                     advance_acc(atb2));
          multiset_eq_same_len(advance_acc(atb1), advance_acc(atb2));
          assert length(advance_acc(atb1)) == length(advance_acc(atb2));
          acc_eq_get_chns_eq(advance_acc(atb1), advance_acc(atb2), t);
      }
  }
}

lemma void chain_just_overflown_in_acc<kt>(list<pair<kt, nat> > acc,
                                           list<bucket<kt> > buckets,
                                           kt k)
requires true == mem(pair(k, nat_of_int(length(buckets))), acc);
ensures true == mem(pair(k, zero), get_wraparound(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          mem_advance_acc_swap(atb, k, nat_of_int(length(buckets) - 1));
          chain_just_overflown_in_acc(advance_acc(atb), t, k);
      }
  }
}//took 1m

lemma void chain_just_overflown_rec<kt>(list<pair<kt, nat> > acc,
                                        list<bucket<kt> > buckets,
                                        kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) ==
         nat_of_int(length(buckets) - start);
ensures true == mem(pair(k, zero), get_wraparound(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (start == 0) {
            bucket_get_chain_mem(chains, k);
            mem_advance_acc_swap(atb, k, nat_of_int(length(buckets) - 1));
            chain_just_overflown_in_acc(advance_acc(atb), t, k);
          } else {
            chain_just_overflown_rec(advance_acc(atb), t, k, start - 1);
          }

      }
  }
}//took 3m

lemma void chain_just_overflown<kt>(list<bucket<kt> > buckets,
                                    kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) ==
         nat_of_int(length(buckets) - start);
ensures true == mem(pair(k, zero), get_wraparound(nil, buckets));
{
  chain_just_overflown_rec(nil, buckets, k, start);
}//took 4m

lemma void distinct_mem_zero_advance_acc_none<kt>(kt k,
                                                  list<pair<kt, nat> > acc)
requires true == distinct(map(fst, acc)) &*&
         true == mem(pair(k, zero), acc);
ensures false == mem(k, map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          if (key == k) {
            switch(dist) {
              case zero:
                advance_acc_still_no_key(t, k);
              case succ(n):
                assert true == mem(pair(k, zero), t);
                mem_map(pair(k, zero), t, fst);
                assert false;
            }
          } else {
            switch(dist) {
              case zero:
              case succ(n):
            }
            distinct_mem_zero_advance_acc_none(k, t);
          }
      }
  }
}//took 6m

lemma void no_cur_key_advance_acc_preserve_mem<kt>(list<pair<kt, nat> > acc,
                                                   kt k)
requires get_current_key_fp(acc) == none;
ensures mem(k, map(fst, acc)) == mem(k, map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      no_cur_key_advance_acc_preserve_mem(t, k);
  }
}//took 1m

lemma void no_cur_key_advance_acc_preserve_distinct<kt>(list<pair<kt, nat> > acc)
requires get_current_key_fp(acc) == none;
ensures distinct(map(fst, acc)) ==
        distinct(map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert false;
            case succ(n):
          }
          no_cur_key_advance_acc_preserve_mem(t, key);
          no_cur_key_advance_acc_preserve_distinct(t);
      }
  }
}//took 3m

lemma void curr_key_no_dup_advance_acc_keep_distinct<kt>(list<pair<kt, nat> > acc,
                                                         kt k)
requires get_current_key_fp(acc) == some(k) &*&
         false == mem(k, map(fst, advance_acc(acc))) &*&
         true == distinct(map(snd, acc)) &*&
         false == distinct(map(fst, acc));
ensures false == distinct(map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert key == k;
              nozero_no_current_key(t);
              no_cur_key_advance_acc_preserve_distinct(t);
              no_cur_key_advance_acc_preserve_mem(t, k);
              assert distinct(map(fst, acc)) ==
                     (!mem(k, map(fst, t)) && distinct(map(fst, t)));
              assert distinct(map(fst, advance_acc(acc))) ==
                     distinct(map(fst, advance_acc(t)));
            case succ(n):
              if (distinct(map(fst, t))) {
                assert true == mem(key, map(fst, t));
                advance_acc_preserves_key(t, key);
                assert true == mem(key, map(fst, advance_acc(t)));
              } else {
                curr_key_no_dup_advance_acc_keep_distinct(t, k);
              }
          }
      }
  }
}//took 8m

lemma void advance_acc_preserve_distinct_keys<kt>(list<pair<kt, nat> > acc)
requires true == distinct(map(fst, acc));
ensures true == distinct(map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
              advance_acc_still_no_key(t, key);
          }
      }
      advance_acc_preserve_distinct_keys(t);
  }
}//took 2m

lemma void buckets_keys_distinct_wraparound_too_rec<kt>(list<pair<kt, nat> > acc,
                                                        list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(buckets)) &*&
         true == distinct(map(fst, acc)) &*&
         true == disjoint(map(fst, acc),
                          buckets_all_keys_fp(buckets));
ensures true == distinct(map(fst, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);

          buckets_distinct_all_keys_breakdown(chains, t);
          msubset_subset(map(fst, chains), buckets_all_keys_fp(buckets));
          msubset_subset(buckets_all_keys_fp(t),
                         buckets_all_keys_fp(buckets));
          disjoint_comm(map(fst, acc),
                        buckets_all_keys_fp(buckets));
          subset_disjoint(map(fst, chains), buckets_all_keys_fp(buckets),
                          map(fst, acc));
          subset_disjoint(buckets_all_keys_fp(t),
                          buckets_all_keys_fp(buckets),
                          map(fst, acc));
          disjoint_comm(map(fst, chains), map(fst, acc));
          disjoint_comm(buckets_all_keys_fp(t), map(fst, acc));
          map_append(fst, acc, chains);
          distinct_and_disjoint_append(map(fst, acc), map(fst, chains));
          advance_acc_preserve_distinct_keys(atb);
          disjoint_append(map(fst, acc), map(fst, chains),
                          nil, buckets_all_keys_fp(t));
          advance_acc_subset_keys(atb);
          subset_disjoint(map(fst, advance_acc(atb)),
                          map(fst, atb),
                          buckets_all_keys_fp(t));
          buckets_keys_distinct_wraparound_too_rec(advance_acc(atb), t);
      }
  }
}//took 6m

lemma void buckets_keys_distinct_wraparound_too<kt>(list<bucket<kt> > buckets)
requires true == distinct(buckets_all_keys_fp(buckets));
ensures true == distinct(map(fst, get_wraparound(nil, buckets)));
{
  buckets_keys_distinct_wraparound_too_rec(nil, buckets);
}//took 3m

lemma void buckets_rem_part_get_chns_lim<kt>(list<bucket<kt> > buckets,
                                             kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) ==
         nat_of_int(length(buckets) - start) &*&
         true == buckets_ok(buckets);
ensures buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_fp(start, length(buckets) - start,
                             buckets_get_chns_fp(buckets));
{
  int dist = length(buckets) - start;
  buckets_keys_chns_same_len(buckets);
  buckets_rem_same_len(buckets, k);
  buckets_keys_chns_same_len(buckets_put_key_fp(buckets, k, start, dist));

  buckets_rem_chain_lim_wraparound_rem_zero_chain(nil, buckets, k, start);

  assert true == multiset_eq
         (get_wraparound(nil, buckets_remove_key_fp(buckets, k)),
          remove(pair(k, zero), get_wraparound(nil, buckets)));
  acc_lacking_zero_chain_same_chns
  (get_wraparound(nil, buckets_remove_key_fp(buckets, k)),
   get_wraparound(nil, buckets),
   buckets, k);
  chain_just_overflown(buckets, k, start);
  buckets_keys_distinct_wraparound_too(buckets);
  assert true == mem(pair(k, zero), get_wraparound(nil, buckets));
  distinct_mem_zero_advance_acc_none(k, get_wraparound(nil, buckets));
  assert false == mem(k, map(fst,
                             advance_acc(get_wraparound(nil, buckets))));
  buckets_rem_part_get_chns_norm_acc_has(get_wraparound(nil, buckets),
                                         buckets, k, start,
                                         length(buckets) - start,
                                         length(buckets));
  acc_lacking_zero_chain_same_chns
  (get_wraparound(nil, buckets_remove_key_fp(buckets, k)),
   get_wraparound(nil, buckets),
   buckets_remove_key_fp(buckets, k), k);
}

lemma void acc_at_this_bucket_keeps_chain<kt>(list<pair<kt, nat> > acc,
                                              kt k, nat dst,
                                              bucket<kt> b)
requires true == mem(pair(k,dst), acc);
ensures true == mem(pair(k, dst), acc_at_this_bucket(acc, b));
{
  switch(b) { case bucket(chains):
  }
}

lemma void acc_has_long_chain_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                                list<bucket<kt> > buckets,
                                                kt k, int dist)
requires true == mem(pair(k,nat_of_int(dist)), acc) &*&
         length(buckets) <= dist;
ensures true == mem(pair(k,nat_of_int(dist - length(buckets))),
                    get_wraparound(acc, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      assert 0 < dist;
      nat dn = nat_of_int(dist);
      switch(dn) {
        case zero:
          assert 0 < length(buckets);
          assert 0 < dist;
          assert int_of_nat(dn) == dist;
          assert dist == 0;
          note(dist == 0);
          note(0 < dist);
          assert false;
        case succ(n):
          acc_at_this_bucket_keeps_chain(acc, k, nat_of_int(dist), h);
          assert true == mem(pair(k,nat_of_int(dist)),
                             acc_at_this_bucket(acc, h));
          mem_advance_acc_swap(acc_at_this_bucket(acc, h),
                               k, n);
          assert true == mem(pair(k,n),
                             advance_acc(acc_at_this_bucket(acc, h)));
          nat m = nat_of_int(dist - 1);
          assert nat_of_int(dist - 1 + 1) == succ(m);
          assert nat_of_int(dist) == succ(m);
          assert nat_of_int(dist) == dn;
          assert succ(m) == dn;
          assert m == n;
          assert nat_of_int(dist - 1) == n;

          assert true == mem(pair(k,nat_of_int(dist - 1)),
                             advance_acc(acc_at_this_bucket(acc, h)));
          acc_has_long_chain_in_wraparound
          (advance_acc(acc_at_this_bucket(acc, h)),
           t, k, dist - 1);

      }
  }
}

lemma void bucket_has_key_in_wraparound_rec<kt>(list<bucket<kt> > buckets,
                                                list<pair<kt, nat> > acc,
                                                kt k, int start, int i)
requires 0 <= start &*& start < length(buckets) &*&
         length(buckets) <= start + i &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         i == int_of_nat(bucket_get_chain_fp(nth(start, buckets), k));
ensures true == mem(pair(k, nat_of_int(start + i - length(buckets))),
                    get_wraparound(acc, buckets));
{
  switch(buckets) {
   case nil:
   case cons(h,t):
     switch(h) {
       case bucket(chains):
         if (start == 0) {
           list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
           bucket_get_chain_mem(chains, k);
           assert true == mem(pair(k, nat_of_int(i)), atb);
           assert 0 < i;
           int prev = i - 1;
           mem_advance_acc_swap(atb, k, nat_of_int(prev));
           acc_has_long_chain_in_wraparound(advance_acc(atb),
                                            t, k, prev);
         } else {
           bucket_has_key_in_wraparound_rec
           (t, advance_acc(acc_at_this_bucket(acc, h)), k, start - 1, i);
         }

     }
  }
}

lemma void bucket_has_key_in_wraparound<kt>(list<bucket<kt> > buckets,
                                            kt k, int start, int i)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         length(buckets) <= i + start &*&
         i == buckets_get_chain_fp(buckets, k, start);
ensures true == mem(pair(k, nat_of_int(start + i - length(buckets))),
                    get_wraparound(nil, buckets));
{
  bucket_has_key_in_wraparound_rec(buckets, nil,
                                   k, start, i);
}//took 110m

lemma void msubset_advance_acc<kt>(list<pair<kt, nat> > acc1,
                                   list<pair<kt, nat> > acc2)
requires true == msubset(acc1, acc2);
ensures true == msubset(advance_acc(acc1), advance_acc(acc2));
{
  switch(acc1) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          msubset_advance_acc(t, remove(pair(key, dist), acc2));
          switch(dist) {
            case zero:
              advance_acc_forget_rem_zero_chain(acc2, key);
            case succ(n):
              mem_advance_acc_swap(acc2, key, n);
              assert true == mem(pair(key, n), advance_acc(acc2));
              advance_acc_remove_swap(acc2, key, n);
          }
      }
  }
}//took 11m

lemma void msubset_buckets_ok_rec<kt>(list<pair<kt, nat> > acc1,
                                      list<pair<kt, nat> > acc2,
                                      list<bucket<kt> > buckets,
                                      int bnd)
requires true == msubset(acc1, acc2) &*&
         true == buckets_ok_rec(acc2, buckets, bnd);
ensures true == buckets_ok_rec(acc1, buckets, bnd);
{
  switch(buckets) {
    case nil:
      msubset_map(snd, acc1, acc2);
      msubset_distinct(map(snd, acc1),
                       map(snd, acc2));
      msubset_subset(acc1, acc2);
      subset_forall(acc1, acc2, (sup)((nat_lt)(bnd - 1), snd));
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          assert true == msubset(acc1, acc2);
          msubset_refl(chains);
          msubset_append_both(acc1, chains, acc2, chains);
          assert true == msubset(atb1, atb2);
          msubset_map(snd, atb1, atb2);
          msubset_distinct(map(snd, atb1),
                           map(snd, atb2));
          msubset_subset(atb1, atb2);
          subset_forall(atb1, atb2, (sup)((nat_lt)(bnd), snd));
          msubset_advance_acc(atb1, atb2);
          msubset_buckets_ok_rec(advance_acc(atb1),
                                 advance_acc(atb2),
                                 t, bnd);
      }
  }
}//took 10m

lemma void buckets_rem_part_get_chns_inv<kt>(list<bucket<kt> > buckets,
                                             kt k, int start, int dist)
requires length(buckets) < start + dist &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*&
         true == buckets_ok(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist);
ensures buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  list<pair<kt, nat> > wrp = get_wraparound(nil, buckets);
  buckets_rem_wraparound_eq_rem(nil, buckets, k, start, dist);
  assert true == multiset_eq
         (get_wraparound(nil, buckets_remove_key_fp(buckets, k)),
          remove(pair(k, nat_of_int(dist + start - length(buckets))),
                 wrp));

  acc_eq_get_chns_eq(get_wraparound(nil, buckets_remove_key_fp(buckets, k)),
                     remove(pair(k, nat_of_int(dist + start - length(buckets))),
                            wrp),
                     buckets_remove_key_fp(buckets, k));
  assert buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
         buckets_get_chns_rec_fp
         (remove(pair(k, nat_of_int(dist + start - length(buckets))),
                 wrp),
          buckets_remove_key_fp(buckets, k));
  buckets_rem_same_len(buckets, k);
  bucket_has_key_in_wraparound(buckets, k, start, dist);
  assert true == mem(pair(k, nat_of_int(dist + start - length(buckets))), wrp);
  acc_remove_chain_get_chns(k, dist + start - length(buckets),
                            wrp,
                            buckets_remove_key_fp(buckets, k));
  assert buckets_get_chns_rec_fp
         (remove(pair(k, nat_of_int(dist + start - length(buckets))),
                 get_wraparound(nil, buckets)),
          buckets_remove_key_fp(buckets, k)) ==
         rem_partial_chain_rec_fp(buckets_get_chns_rec_fp(get_wraparound(nil, buckets),
                                                          buckets_remove_key_fp(buckets, k)),
                                  0, dist + start - length(buckets));
  buckets_rem_part_get_chns_norm_rec(wrp,
                                     buckets,
                                     k, start,
                                     dist,
                                     length(buckets));
  buckets_keys_chns_same_len(buckets);
}

lemma void buckets_rem_part_get_chns<kt>(list<bucket<kt> > buckets,
                                         kt k, int start, int dist)
requires 0 <= start &*& start < length(buckets) &*&
         0 <= dist &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         bucket_get_chain_fp(nth(start, buckets), k) == nat_of_int(dist) &*&
         true == buckets_ok(buckets);
ensures buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
        rem_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  if (dist + start == length(buckets)) {
    buckets_rem_part_get_chns_lim(buckets, k, start);
  } else if (length(buckets) < dist + start) {
    buckets_rem_part_get_chns_inv(buckets, k, start, dist);
  } else {
    buckets_rem_part_get_chns_norm(buckets, k, start, dist);
  }
}

//<---- rem_partial_chain_symmetric_lemmas start here

lemma void add_rem_part_chain_rec(list<int> chns,
                                  int start,
                                  int len)
requires 0 <= start &*& 0 <= len;
ensures chns ==
        add_partial_chain_rec_fp(
          rem_partial_chain_rec_fp(chns,
                                   start,
                                   len),
          start, len);
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len == 0) {
        } else {
          add_rem_part_chain_rec(t, 0, len - 1);
        }
      } else {
        add_rem_part_chain_rec(t, start - 1, len);
      }
  }
}

lemma void rem_part_chn_rec_same_len(int start,
                                     int len,
                                     list<int> chn_cnts)
requires true;
ensures length(chn_cnts) ==
        length(rem_partial_chain_rec_fp(chn_cnts,
                                        start, len));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0)
        rem_part_chn_rec_same_len(0, len-1, t);
      } else {
        rem_part_chn_rec_same_len(start - 1, len, t);
      }
  }
}

lemma void rem_partial_chain_same_len(int start,
                                      int len,
                                      list<int> chns)
requires true;
ensures length(chns) ==
        length(rem_partial_chain_fp(start, len, chns));
{
  if (length(chns) < len + start) {
    rem_part_chn_rec_same_len(start, len, chns);
    rem_part_chn_rec_same_len(0, len + start - length(chns),
                              rem_partial_chain_rec_fp(chns,
                                                       start,
                                                       len));
  } else {
    rem_part_chn_rec_same_len(start, len, chns);
  }
}//took 3m

lemma void rem_part_chn_rec_swap(list<int> chns,
                                 int st1, int l1,
                                 int st2, int l2)
requires 0 <= st1 &*& 0 <= l1 &*&
         0 <= st2 &*& 0 <= l2;
ensures rem_partial_chain_rec_fp(rem_partial_chain_rec_fp
                                 (chns, st1, l1),
                                 st2, l2) ==
        rem_partial_chain_rec_fp(rem_partial_chain_rec_fp
                                 (chns, st2, l2),
                                 st1, l1);
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (st1 == 0 && st2 == 0 && l1 != 0 && l2 != 0) {
        rem_part_chn_rec_swap(t,
                              0, l1 -1,
                              0, l2 - 1);
      } else if (st1 == 0 && st2 != 0 && l1 != 0) {
        rem_part_chn_rec_swap(t,
                              0, l1 - 1,
                              st2 - 1, l2);
      } else if (st1 != 0 && st2 == 0 && l2 != 0) {
        rem_part_chn_rec_swap(t,
                              st1 - 1, l1,
                              0, l2 - 1);
      } else if (st1 != 0 && st2 != 0) {
        rem_part_chn_rec_swap(t,
                              st1 - 1, l1,
                              st2 - 1, l2);
      }
  }
}

lemma void add_rem_part_chain(int start,
                              int len,
                              list<int> chns)
requires 0 <= start &*& start < length(chns) &*& 0 <= len;
ensures chns ==
        add_partial_chain_fp(start, len,
                             rem_partial_chain_fp(start, len,
                                                  chns));
{
  rem_part_chn_rec_same_len(start, len, chns);
  if (length(chns) < start + len) {
    rem_part_chn_rec_same_len(0, len + start - length(chns),
                              rem_partial_chain_rec_fp(chns, start, len));
    rem_part_chn_rec_swap(chns,
                          start, len,
                          0, len + start - length(chns));
    add_rem_part_chain_rec(
      rem_partial_chain_rec_fp(chns,
                               0,
                               len + start - length(chns)),
      start, len);
    add_rem_part_chain_rec(chns,
                           0,
                           len + start - length(chns));
  } else {
    rem_part_chn_rec_same_len(start, len, chns);
    add_rem_part_chain_rec(chns, start, len);
  }
}

lemma void buckets_remove_add_one_chain<kt>(list<bucket<kt> > buckets,
                                            int start, kt k)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == buckets_ok(buckets);
ensures buckets_get_chns_fp(buckets) ==
        add_partial_chain_fp(
          start, buckets_get_chain_fp(buckets, k, start),
          buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)));
{
  nat ndist = bucket_get_chain_fp(nth(start, buckets), k);
  int dist = int_of_nat(ndist);
  buckets_rem_part_get_chns(buckets, k, start, dist);
  list<int> orig_chains = buckets_get_chns_fp(buckets);
  buckets_keys_chns_same_len(buckets);
  add_rem_part_chain(start, dist, orig_chains);
}

lemma void buckets_get_chns_rec_nonneg<kt>(list<pair<kt, nat> > acc,
                                           list<bucket<kt> > buckets)
requires true;
ensures true == forall(buckets_get_chns_rec_fp(acc, buckets), (ge)(0));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_get_chns_rec_nonneg(advance_acc(acc_at_this_bucket(acc, h)), t);
  }
}

lemma void buckets_get_chns_nonneg<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == forall(buckets_get_chns_fp(buckets), (ge)(0));
{
  buckets_get_chns_rec_nonneg(get_wraparound(nil, buckets), buckets);
}

lemma void add_part_chn_rec_still_nonneg(int start, int len,
                                         list<int> chn_cnts)
requires true == forall(chn_cnts, (ge)(0));
ensures true == forall(add_partial_chain_rec_fp(chn_cnts,
                                                start, len),
                       (ge)(0));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0) add_part_chn_rec_still_nonneg(0, len - 1, t);
      } else {
        add_part_chn_rec_still_nonneg(start - 1, len, t);
      }
  }
}

lemma void add_partial_chain_rec_nonneg(int start, int len, list<int> chn_cnts)
requires true == forall(chn_cnts, (ge)(0));
ensures true == forall(add_partial_chain_rec_fp(chn_cnts, start, len), (ge)(0));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0) {
          add_partial_chain_rec_nonneg(0, len - 1, t);
        }
      } else {
        add_partial_chain_rec_nonneg(start - 1, len, t);
      }
  }
}

lemma void add_partial_chain_nonneg(int i, int len, list<int> chn_cnts)
requires true == forall(chn_cnts, (ge)(0));
ensures true == forall(add_partial_chain_fp(i, len, chn_cnts), (ge)(0));
{
  if (length(chn_cnts) < len + i) {
    add_partial_chain_rec_nonneg(i, len, chn_cnts);
    add_partial_chain_rec_nonneg(0, len + i - length(chn_cnts),
                                 add_partial_chain_rec_fp(chn_cnts, i, len));
  } else {
    add_partial_chain_rec_nonneg(i, len, chn_cnts);
  }
}

lemma void add_part_chn_rec_same_len(int start, int len, list<int> chn_cnts)
requires true;
ensures length(chn_cnts) ==
        length(add_partial_chain_rec_fp(chn_cnts, start, len));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0)
        add_part_chn_rec_same_len(0, len-1, t);
      } else {
        add_part_chn_rec_same_len(start - 1, len, t);
      }
  }
}

lemma void add_part_chn_gt0_rec(int i, int len, list<int> chn_cnts)
requires len != 0 &*& 0 <= i &*& i < length(chn_cnts) &*&
         true == forall(chn_cnts, (ge)(0));
ensures 0 < nth(i, add_partial_chain_rec_fp(chn_cnts, i, len));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (i == 0) {
      } else {
        add_part_chn_gt0_rec(i-1, len, t);
      }
  }
}

lemma void add_part_chn_still_gt0_rec(int i, int start, int len,
                                      list<int> chn_cnts)
requires 0 <= i &*& i < length(chn_cnts) &*&
         0 <= start &*& start <= i &*&
         0 < nth(i, chn_cnts) &*&
         true == forall(chn_cnts, (ge)(0));
ensures 0 < nth(i, add_partial_chain_rec_fp(chn_cnts, start, len));
{
  switch(chn_cnts) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0) {
          if (i != 0)
          add_part_chn_still_gt0_rec(i - 1, 0, len - 1, t);
        }
      } else {
        note(0 < start);
        add_part_chn_still_gt0_rec(i - 1, start - 1, len, t);
      }
  }
}

lemma void add_part_chn_gt0(int i, int len, list<int> chn_cnts)
requires 0 <= i &*& i < length(chn_cnts) &*&
         0 < len &*&
         true == forall(chn_cnts, (ge)(0));
ensures 0 < nth(i, add_partial_chain_fp(i, len, chn_cnts));
{
  if (length(chn_cnts) < len + i) {
    add_part_chn_gt0_rec(i, len, chn_cnts);
    add_part_chn_rec_same_len(i, len, chn_cnts);
    add_part_chn_rec_still_nonneg(i, len, chn_cnts);
    add_part_chn_still_gt0_rec(i, 0, len + i - length(chn_cnts),
                               add_partial_chain_rec_fp(chn_cnts, i, len));
  } else {
    add_part_chn_gt0_rec(i, len, chn_cnts);
  }
}//took 80m

lemma void remove_one_cell_from_part_ch_rec(list<int> chns, int index,
                                            int len, list<int> src_chns)
requires chns == add_partial_chain_rec_fp(src_chns,
                                          index,
                                          len) &*&
         0 <= index &*& index + 1 < length(src_chns) &*&
         0 < len;
ensures update(index, nth(index, chns) - 1, chns) ==
        add_partial_chain_rec_fp(src_chns, index + 1, len - 1);
{
  switch(src_chns) {
    case nil:
    case cons(h,t):
      if (index == 0) {
      } else {
        assert chns == cons(h, ?rest);
        assert rest == add_partial_chain_rec_fp(t, index - 1, len);
        remove_one_cell_from_part_ch_rec(rest, index - 1, len, t);
      }
  }
}

lemma void add_part_chn_rec_preserves_decrement(list<int> chns,
                                                list<int> src_chns,
                                                int start,
                                                int len,
                                                int index)
requires chns == add_partial_chain_rec_fp(src_chns, start, len) &*&
         0 <= index &*& index < length(src_chns);
ensures update(index, nth(index, chns) - 1, chns) ==
        add_partial_chain_rec_fp(update(index,
                                        nth(index, src_chns) - 1,
                                        src_chns),
                                 start, len);
{
  switch(src_chns) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0) {
          if (index != 0) {
            assert chns == cons(h+1,?rest);
            add_part_chn_rec_preserves_decrement(rest, t, 0,
                                                 len - 1, index - 1);
          }
        }
      } else {
        assert chns == cons(h,?rest);
        if (index != 0)
        add_part_chn_rec_preserves_decrement(rest, t, start - 1,
                                             len, index - 1);
      }
  }
}

lemma void dec_cancels_inc(list<int> lst, int index)
requires 0 <= index &*& index < length(lst);
ensures update(index, nth(index, update(index, nth(index, lst) + 1, lst)) - 1,
               update(index, nth(index, lst) + 1, lst)) == lst;
{
  switch(lst) {
    case nil:
    case cons(h,t):
      if (index != 0) dec_cancels_inc(t, index - 1);
  }
}

lemma void add_part_chn_rec_inc_last(list<int> chns, int len)
requires 0 < len &*& 0 < length(chns);
ensures add_partial_chain_rec_fp(chns, length(chns) - 1, len) ==
        update(length(chns) - 1, nth(length(chns) - 1, chns) + 1, chns);
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (length(chns) == 1) {
        length_0_nil(t);
      } else {
        add_part_chn_rec_inc_last(t, len);
      }
  }
}

lemma void add_part_chn_rec_zero_len(list<int> chns, int start)
requires true;
ensures add_partial_chain_rec_fp(chns, start, 0) == chns;
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (start != 0) add_part_chn_rec_zero_len(t, start - 1);
  }
}

lemma void add_part_chn_zero_len(list<int> chns, int start)
requires 0 <= start &*& start < length(chns); //optional
ensures add_partial_chain_fp(start, 0, chns) == chns;
{
  add_part_chn_rec_zero_len(chns, start);
}

lemma void remove_one_cell_from_partial_chain(list<int> chns, int index,
                                              int len, list<int> src_chns,
                                              int capacity)
requires chns == add_partial_chain_fp(index,
                                      len, src_chns) &*&
         length(src_chns) == capacity &*&
         0 <= index &*& index < capacity &*&
         0 < len &*& len <= capacity;
ensures update(index, nth(index, chns) - 1, chns) ==
        add_partial_chain_fp(loop_fp(index + 1, capacity),
                             len - 1, src_chns);
{
  if (index == capacity - 1) {
    loop_injection_n(index + 1 - capacity, capacity, 1);
    loop_bijection(index + 1 - capacity, capacity);
    assert loop_fp(index + 1, capacity) == 0;
    add_part_chn_rec_inc_last(src_chns, len);
    if (capacity < index + len) {
      list<int> interim = update(index, nth(index, src_chns) + 1, src_chns);
      dec_cancels_inc(src_chns, index);
      assert update(index, nth(index, interim) - 1, interim) == src_chns;
      assert add_partial_chain_rec_fp(src_chns, index, len) ==
             update(index, nth(index, src_chns) + 1, src_chns);
      add_part_chn_rec_same_len(index, len, src_chns);
      add_part_chn_rec_preserves_decrement
      (chns, update(index, nth(index, src_chns) + 1, src_chns),
       0, len + index - length(src_chns), index);
      assert chns == add_partial_chain_rec_fp(interim, 0, len + index - length(src_chns));
      assert update(index, nth(index, chns) - 1, chns) ==
             add_partial_chain_rec_fp(update(index, nth(index, interim) - 1, interim),
                                      0, len + index - length(src_chns));
      assert update(index, nth(index, chns) - 1, chns) ==
             add_partial_chain_rec_fp(src_chns,
                                      0, len + index - length(src_chns));
      assert loop_fp(index + 1, capacity) == 0;
      assert len + index - length(src_chns) == len - 1;
      assert len - 1 < capacity;
      assert add_partial_chain_rec_fp(src_chns, 0, len + index - length(src_chns)) ==
             add_partial_chain_fp(loop_fp(index + 1, capacity), len - 1, src_chns);
    } else {
      assert len == 1;
      dec_cancels_inc(src_chns, index);
      add_part_chn_rec_zero_len(src_chns, loop_fp(index + 1, capacity));
    }
  } else {
    loop_bijection(index + 1, capacity);
    assert loop_fp(index + 1, capacity) == index + 1;
    if (capacity < index + len) {
      list<int> chns0 = add_partial_chain_rec_fp(src_chns, index, len);
      remove_one_cell_from_part_ch_rec(chns0, index, len, src_chns);
      assert chns == add_partial_chain_rec_fp(chns0, 0,
                                              len + index - length(src_chns));
      add_part_chn_rec_same_len(index, len, src_chns);
      add_part_chn_rec_preserves_decrement(chns, chns0,
                                           0,
                                           len + index - length(src_chns),
                                           index);
      assert update(index, nth(index, chns) - 1, chns) ==
             add_partial_chain_rec_fp(update(index,
                                             nth(index, chns0) - 1, chns0),
                                      0,
                                      len + index - length(src_chns));
    } else {
      remove_one_cell_from_part_ch_rec(chns, index, len, src_chns);
    }
  }
}//took 145m

lemma void chain_with_key_bounded<kt>(list<pair<kt,nat> > chains,
                                      kt k, int bound)
requires true == forall(chains, (sup)((nat_lt)(bound), snd)) &*&
         0 < bound;
ensures int_of_nat(chain_with_key_fp(chains, k)) < bound;
{
  switch(chains) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,len):
          if (key != k) {
            chain_with_key_bounded(t, k, bound);
          }
      }
  }
}

lemma void buckets_ok_rec_get_chain_bounded<kt>(list<pair<kt, nat> > acc,
                                                list<bucket<kt> > buckets,
                                                int bound,
                                                kt k, int start)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         0 <= start &*& start < length(buckets) &*&
         0 < bound;
ensures buckets_get_chain_fp(buckets, k, start) < bound;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        switch(h) {
          case bucket(chains):
            forall_append(acc, chains, (sup)((nat_lt)(bound), snd));
            assert true == forall(chains, (sup)((nat_lt)(bound), snd));
            chain_with_key_bounded(chains, k, bound);
        }
      } else {
        buckets_ok_rec_get_chain_bounded
        (advance_acc(acc_at_this_bucket(acc, h)),
         t, bound, k, start - 1);
      }
  }
}

lemma void buckets_ok_get_chain_bounded<kt>(list<bucket<kt> > buckets,
                                            kt k, int start)
requires true == buckets_ok(buckets) &*&
         0 <= start &*& start < length(buckets);
ensures buckets_get_chain_fp(buckets, k, start) < length(buckets) &*&
        0 <= buckets_get_chain_fp(buckets, k, start);
{
  buckets_ok_rec_get_chain_bounded(get_wraparound(nil, buckets),
                                   buckets, length(buckets), k, start);
}//took 25m

lemma void add_partial_chain_same_len(int start, int len, list<int> chns)
requires true;
ensures length(chns) == length(add_partial_chain_fp(start, len, chns));
{
  if (length(chns) < len + start) {
    add_part_chn_rec_same_len(start, len, chns);
    add_part_chn_rec_same_len(0, len + start - length(chns),
                              add_partial_chain_rec_fp(chns, start, len));
  } else {
    add_part_chn_rec_same_len(start, len, chns);
  }
}//took 3m

lemma void acc_has_chain_longer<kt>(list<pair<kt, nat> > acc,
                                    list<bucket<kt> > buckets,
                                    nat dst, kt k,
                                    int i,
                                    int bound)
requires 0 <= i &*& i < length(buckets) &*&
         nth(i, buckets_get_keys_rec_fp(acc, buckets)) != some(k) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         true == mem(pair(k,dst), acc);
ensures int_of_nat(dst) != i;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (i == 0) {
        switch(dst) {
          case zero:
            acc_at_this_bucket_keeps_chain(acc, k, dst, h);
            distinct_and_zero_this_is_the_key(acc_at_this_bucket(acc, h), k);
            assert get_current_key_fp(acc_at_this_bucket(acc, h)) == some(k);
            assert false;
          case succ(n):
            assert 0 != int_of_nat(dst);
        }
      } else {
        switch(dst) {
          case zero: return;
          case succ(n):
            acc_at_this_bucket_keeps_chain(acc, k, dst, h);
            advance_acc_shortens_chain(acc_at_this_bucket(acc, h), k, dst);
            acc_has_chain_longer(advance_acc(acc_at_this_bucket(acc, h)),
                                 t, n, k, i - 1, bound);
        }
      }
  }
}

lemma void acc_has_chain_here_is_the_key<kt>(list<pair<kt, nat> > acc,
                                             list<bucket<kt> > buckets,
                                             kt k, int dst, int bound)
requires 0 <= dst &*& dst < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         true == mem(pair(k, nat_of_int(dst)), acc);
ensures nth(dst, buckets_get_keys_rec_fp(acc, buckets)) ==
        some(k);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (dst == 0) {
            distinct_and_zero_this_is_the_key(atb, k);
          } else {
            mem_advance_acc_swap(atb, k, nat_of_int(dst - 1));
            acc_has_chain_here_is_the_key(advance_acc(atb),
                                          t, k, dst - 1, bound);
          }
      }
  }
}//took 7m

lemma void buckets_get_chain_longer_rec<kt>(list<bucket<kt> > buckets,
                                            list<pair<kt, nat> > acc,
                                            int start, int i, kt k,
                                            int bound)
requires 0 <= i &*& start + i < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         0 <= start &*&
         nth(start + i, buckets_get_keys_rec_fp(acc, buckets)) != some(k) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         false == mem(k, map(fst, acc));
ensures buckets_get_chain_fp(buckets, k, start) != i;
{
  switch(buckets) {
   case nil:
   case cons(bh,bt):
     switch(bh) {
       case bucket(chains):
         list<pair<kt, nat> > atb = acc_at_this_bucket(acc, bh);
         if (start == 0) {
           nat dst = bucket_get_chain_fp(bh, k);
           if (length(buckets) <= int_of_nat(dst)) return;
           bucket_get_chain_mem(chains, k);
           switch(dst) {
             case zero:
               distinct_and_zero_this_is_the_key(atb, k);
             case succ(dp):
               mem_advance_acc_swap(atb, k, dp);
               acc_has_chain_here_is_the_key(advance_acc(atb), bt,
                                             k, int_of_nat(dp), bound);
           }
         } else {
           buckets_distinct_all_keys_breakdown(chains, bt);
           distinct_key_in_following_not_in_the_first_bucket(k, start-1, chains,
                                                             bt);
           map_append(fst, acc, chains);
           advance_acc_still_no_key(atb, k);
           buckets_get_chain_longer_rec
           (bt, advance_acc(atb),
            start - 1, i, k, bound);
         }
     }
  }
}

lemma void buckets_get_chain_longer<kt>(list<bucket<kt> > buckets,
                                        int start, int i, kt k,
                                        int capacity)
requires nth(loop_fp(start + i, capacity),
             buckets_get_keys_fp(buckets)) != some(k) &*&
         length(buckets) == capacity &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= i &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == buckets_ok(buckets);
ensures buckets_get_chain_fp(buckets, k, start) != i;
{
  if (start + i < capacity) {
    loop_bijection(start + i, capacity);
    if (buckets_get_chain_fp(buckets, k, start) == i) {
      short_chain_does_not_wraparound(buckets, k, start, i);
      buckets_get_chain_longer_rec(buckets, get_wraparound(nil, buckets),
                                   start, i, k, capacity);
    }
  } else {
    if (capacity <= start + i - capacity) {
      assert capacity < i;
      buckets_ok_get_chain_bounded(buckets, k, start);
    } else {
      assert start + i - capacity < capacity;
      if (buckets_get_chain_fp(buckets, k, start) == i) {
        bucket_has_key_in_wraparound(buckets, k, start, i);
        assert true == mem(pair(k, nat_of_int(start + i - capacity)),
                           get_wraparound(nil, buckets));
        loop_injection_n(start + i - capacity, capacity, 1);
        loop_bijection(start + i - capacity, capacity);
        acc_has_chain_longer(get_wraparound(nil, buckets), buckets,
                             nat_of_int(start + i - capacity),
                             k, start + i - capacity,
                             capacity);
        assert false;
      }
    }
  }
}

lemma void unadvance_acc_mem<kt>(list<pair<kt, nat> > acc, kt k, nat dst)
requires true == mem(pair(k, dst), advance_acc(acc));
ensures true == mem(pair(k, succ(dst)), acc);
{
  mem_advance_acc_swap(acc, k, dst);
}//took 2m

lemma void current_key_pair_zero<kt>(list<pair<kt, nat> > acc, kt k)
requires get_current_key_fp(acc) == some(k);
ensures true == mem(pair(k, zero), acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert k == key;
            case succ(n):
              current_key_pair_zero(t, k);
          }
      }
  }
}//took 1m

lemma void acc_chain_end_rec<kt>(list<pair<kt, nat> > acc,
                                 list<bucket<kt> > buckets,
                                 kt k, int dist, int bound)
requires nth(dist, buckets_get_keys_rec_fp(acc, buckets)) == some(k) &*&
         0 <= dist &*& dist < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         false == mem(k, buckets_all_keys_fp(buckets));
ensures true == mem(pair(k, nat_of_int(dist)), acc);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (mem(pair(k, nat_of_int(dist)), chains)) {
            mem_map(pair(k, nat_of_int(dist)), chains, fst);
          }
          assert false == mem(pair(k, nat_of_int(dist)), chains);
          if (dist == 0) {
            current_key_pair_zero(atb, k);
          } else {
            acc_chain_end_rec(advance_acc(atb), t, k, dist - 1, bound);
            unadvance_acc_mem(atb, k, nat_of_int(dist - 1));
            assert true == mem(pair(k, nat_of_int(dist)), atb);
            assert false == mem(k, map(fst, chains));
          }
      }
  }
}

lemma void key_not_here_nor_there_not_in_the_get_keys<kt>(list<pair<kt, nat> > acc,
                                                          list<bucket<kt> > buckets,
                                                          kt k, int x)
requires 0 <= x &*& x < length(buckets) &*&
         false == mem(k, map(fst, acc)) &*&
         false == mem(k, buckets_all_keys_fp(buckets));
ensures nth(x, buckets_get_keys_rec_fp(acc, buckets)) != some(k);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          map_append(fst, acc, chains);
          if (x == 0) {
            no_key_certainly_not_here(atb, k);
          } else {
            advance_acc_still_no_key(atb, k);
            key_not_here_nor_there_not_in_the_get_keys(advance_acc(atb),
                                                       t, k, x - 1);
          }
      }
  }
}//took 3m

lemma void key_not_in_acc_then_in_buckets<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets,
                                              kt k, int x)
requires 0 <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == some(k) &*&
         false == mem(k, map(fst, acc));
ensures true == mem(k, buckets_all_keys_fp(buckets));
{
  if (! mem(k, buckets_all_keys_fp(buckets))) {
    key_not_here_nor_there_not_in_the_get_keys(acc, buckets, k, x);
  }
}//took 5m

lemma void advance_last_chain_with_zero_nonmem<kt>(list<pair<kt, nat> > acc,
                                                   kt k)
requires true == mem(pair(k, zero), acc) &*&
         false == mem(k, remove(k, map(fst, acc)));
ensures false == mem(k, map(fst, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          if (key == k) {
            switch(dist) {
              case zero:
                advance_acc_still_no_key(t, k);
                return;
              case succ(n):
                mem_map(pair(k, zero), t, fst);
                assert false;
            }
          } else {
            switch(dist) {
              case zero:
              case succ(n):
            }
            advance_last_chain_with_zero_nonmem(t, k);
          }
      }
  }
}//took 10m

lemma void buckets_chain_end_rec<kt>(list<pair<kt, nat> > acc,
                                     list<bucket<kt> > buckets,
                                     kt k, int start, int i,
                                     int capacity)
requires nth(start + i, buckets_get_keys_rec_fp(acc, buckets)) ==
         some(k) &*&
         0 < capacity &*&
         0 <= start &*&
         0 <= i &*&
         length(buckets) <= capacity &*&
         start + i < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, capacity) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         false == mem(k, map(fst, acc));
ensures buckets_get_chain_fp(buckets, k, start) == i;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      switch(h) {
        case bucket(chains):
          map_append(fst, acc, chains);
          buckets_distinct_all_keys_breakdown(chains, t);
          remove_append_swap(k, map(fst, acc), map(fst, chains));
          distinct_unique(map(fst, chains), k);
          if (start == 0) {
            nat chn = bucket_get_chain_fp(h, k);
            bucket_get_chain_mem(chains, k);
            switch(chn) {
              case zero:
                if (i != 0) {
                  assert true == mem(pair(k, zero), chains);
                  assert true == mem(k, map(fst, chains));
                  advance_last_chain_with_zero_nonmem(atb, k);
                  distinct_key_in_here_not_in_the_following(k, chains, t);
                  key_not_in_acc_then_in_buckets(advance_acc(atb),
                                                 t, k, i - 1);
                  assert true == mem(k, buckets_all_keys_fp(t));
                  assert false;
                }
                return;
              case succ(pchn):
                if (i == 0) {
                  current_key_pair_zero(atb, k);
                  assert true == mem(pair(k, chn), atb);
                  assert true == mem(pair(k, zero), atb);
                  unique_map_identical_elems(fst, atb, pair(k, nat_of_int(i)),
                                             pair(k, chn));
                  return;
                }
                distinct_key_in_here_not_in_the_following(k, chains, t);
                acc_chain_end_rec(advance_acc(atb), t,
                                  k, i - 1, capacity);
            }
            assert true == mem(pair(k, nat_of_int(i - 1)), advance_acc(atb));
            mem_advance_acc_swap(atb, k, nat_of_int(i - 1));
            assert true == mem(pair(k, nat_of_int(i)), atb);
            assert true == mem(pair(k, chn), chains);
            assert true == mem(pair(k, chn), atb);
            assert false == mem(k, remove(k, map(fst, atb)));
            unique_map_identical_elems(fst, atb, pair(k, nat_of_int(i)),
                                       pair(k, chn));
            assert nat_of_int(i) == chn;
            assert bucket_get_chain_fp(h, k) == nat_of_int(i);
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            this_bucket_still_no_key(acc, h, k);
            advance_acc_still_no_key(atb, k);
            buckets_chain_end_rec(advance_acc(atb),
                                  t, k, start - 1, i, capacity);
          }
      }
  }
}

lemma void split_one_bucket_no_key_lost<kt>(list<pair<kt, nat> > acc, int bnd)
requires true;
ensures true == multiset_eq(append(map(fst, filter((sup)((nat_ge)(bnd), snd),
                                                   acc)),
                                   map(fst, filter((sup)((nat_lt)(bnd), snd),
                                                   acc))),
                            map(fst, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          split_one_bucket_no_key_lost(t, bnd);
          if ((sup)((nat_ge)(bnd), snd)(h)) {
          } else {
            cons_in_the_middle_multiset_eq(map(fst, filter((sup)((nat_ge)(bnd),
                                                                 snd),
                                                           t)),
                                           map(fst, filter((sup)((nat_lt)(bnd),
                                                                 snd),
                                                           t)),
                                           key);
            multiset_eq_trans(append(map(fst,
                                         filter((sup)((nat_ge)(bnd), snd), t)),
                                     cons(key,
                                          map(fst,
                                              filter((sup)((nat_lt)(bnd), snd),
                                                     t)))),
                              cons(key,
                                   append(map(fst,
                                              filter((sup)((nat_ge)(bnd), snd),
                                                          t)),
                                          map(fst,
                                              filter((sup)((nat_lt)(bnd), snd),
                                                          t)))),
                              cons(key, map(fst, t)));
          }
      }
  }
}//took 10m

lemma void multiset_eq_reshuffle_appends<t>(list<t> l1, list<t> l2,
                                            list<t> l3, list<t> l4,
                                            list<t> l5)
requires true == multiset_eq(l1, append(append(l2, l3), append(l4, l5)));
ensures true == multiset_eq(l1, append(append(l2, l5), append(l3, l4)));
{
  multiset_eq_append_assoc(l2, l3, append(l4, l5));
  multiset_eq_trans(l1, append(append(l2, l3),
                               append(l4, l5)),
                    append(l2, append(l3, append(l4, l5))));
  assert true == multiset_eq(l1, append(l2, append(l3, append(l4, l5))));
  multiset_eq_append_assoc(l3, l4, l5);
  multiset_eq_comm(append(append(l3, l4), l5),
                   append(l3, append(l4, l5)));
  multiset_eq_append_comm(append(l3, l4), l5);
  multiset_eq_trans(append(l3, append(l4, l5)),
                    append(append(l3, l4), l5),
                    append(l5, append(l3, l4)));
  multiset_eq_refl(l2);
  multiset_eq_append(l2, l2,
                     append(l3, append(l4, l5)),
                     append(l5, append(l3, l4)));
  multiset_eq_trans(l1,
                    append(l2, append(l3, append(l4, l5))),
                    append(l2, append(l5, append(l3, l4))));
  assert true == multiset_eq(l1, append(l2, append(l5, append(l3, l4))));
  multiset_eq_append_assoc(l2, l5, append(l3, l4));
  multiset_eq_comm(append(append(l2, l5), append(l3, l4)),
                   append(l2, append(l5, append(l3, l4))));
  assert true == multiset_eq(append(l2, append(l5, append(l3, l4))),
                             append(append(l2, l5), append(l3, l4)));
  assert true == multiset_eq(append(l2, append(l5, append(l3, l4))),
                             append(append(l2, l5), append(l3, l4)));

  multiset_eq_trans(l1, append(l2, append(l5, append(l3, l4))),
                    append(append(l2, l5), append(l3, l4)));
}

lemma void buckets_split_all_keys<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == multiset_eq(append
                            (buckets_all_keys_fp(keep_short_fp(buckets)),
                             buckets_all_keys_fp(keep_long_fp(buckets))),
                            buckets_all_keys_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > lchns = filter((sup)((nat_ge)(length(buckets)), snd),
                                              chains);
          list<pair<kt, nat> > schns = filter((sup)((nat_lt)(length(buckets)), snd),
                                              chains);
          split_one_bucket_no_key_lost(chains, length(buckets));
          buckets_split_all_keys(t);
          assert true == multiset_eq(append
                                     (buckets_all_keys_fp(keep_short_fp(t)),
                                      buckets_all_keys_fp(keep_long_fp(t))),
                                     buckets_all_keys_fp(t));
          multiset_eq_append(append(map(fst, lchns), map(fst, schns)),
                             map(fst, chains),
                             append
                             (buckets_all_keys_fp(keep_short_fp(t)),
                              buckets_all_keys_fp(keep_long_fp(t))),
                             buckets_all_keys_fp(t));
          assert true == multiset_eq(append(append(map(fst, lchns), map(fst, schns)),
                                            append
                                            (buckets_all_keys_fp(keep_short_fp(t)),
                                             buckets_all_keys_fp(keep_long_fp(t)))),
                                     append(map(fst, chains),
                                            buckets_all_keys_fp(t)));
          multiset_eq_comm(append(append(map(fst, lchns), map(fst, schns)),
                                  append
                                  (buckets_all_keys_fp(keep_short_fp(t)),
                                   buckets_all_keys_fp(keep_long_fp(t)))),
                           buckets_all_keys_fp(buckets));
          multiset_eq_reshuffle_appends(buckets_all_keys_fp(buckets),
                                        map(fst, lchns),
                                        map(fst, schns),
                                        buckets_all_keys_fp(keep_short_fp(t)),
                                        buckets_all_keys_fp(keep_long_fp(t)));
          multiset_eq_append_comm(buckets_all_keys_fp(keep_long_fp(buckets)),
                                  buckets_all_keys_fp(keep_short_fp(buckets)));
          multiset_eq_trans(buckets_all_keys_fp(buckets),
                            append(buckets_all_keys_fp(keep_long_fp(buckets)),
                                   buckets_all_keys_fp(keep_short_fp(buckets))),
                            append(buckets_all_keys_fp(keep_short_fp(buckets)),
                                   buckets_all_keys_fp(keep_long_fp(buckets))));
          multiset_eq_comm(buckets_all_keys_fp(buckets),
                           append(buckets_all_keys_fp(keep_short_fp(buckets)),
                                  buckets_all_keys_fp(keep_long_fp(buckets))));
      }
  }
}//took 19m

lemma void long_chain_in_keep_long<kt>(list<bucket<kt> > buckets,
                                       kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         length(buckets) <=
         start + buckets_get_chain_fp(buckets, k, start);
ensures true == mem(k, buckets_all_keys_fp(keep_long_fp(buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
            bucket_get_chain_mem(chains, k);
            int dist = buckets_get_chain_fp(buckets, k, start);
            nat ndist = nat_of_int(dist);
            filter_mem(pair(k, ndist), chains,
                       (sup)((nat_ge)(length(buckets)), snd));
            mem_map(pair(k, ndist),
                    filter((sup)((nat_ge)(length(buckets)), snd),
                           chains), fst);
          } else {
            long_chain_in_keep_long(t, k, start - 1);
          }
      }
  }
}//took 29 /distracted

lemma void short_chain_in_keep_short<kt>(list<bucket<kt> > buckets,
                                         kt k, int start)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         start + buckets_get_chain_fp(buckets, k, start) <
         length(buckets);
ensures true == mem(k, buckets_all_keys_fp(keep_short_fp(buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
            bucket_get_chain_mem(chains, k);
            int dist = buckets_get_chain_fp(buckets, k, start);
            nat ndist = nat_of_int(dist);
            filter_mem(pair(k, ndist), chains,
                       (sup)((nat_lt)(length(buckets)), snd));
            mem_map(pair(k, ndist),
                    filter((sup)((nat_lt)(length(buckets)), snd),
                           chains), fst);
          } else {
            short_chain_in_keep_short(t, k, start - 1);
          }
      }
  }
}//took 4m

lemma void advance_acc_cutoff_swap<kt>(list<pair<kt, nat> > acc, int cutoff)
requires 0 < cutoff;
ensures advance_acc(filter((sup)((nat_lt)(cutoff), snd), acc)) ==
        filter((sup)((nat_lt)(cutoff-1), snd), advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
        advance_acc_cutoff_swap(t, cutoff);
      }
  }
}

lemma void long_chain_does_not_make_it_to_keys<kt>(kt k, int dist,
                                                   list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets)
requires length(buckets) <= dist;
ensures buckets_get_keys_rec_fp(acc, buckets) ==
        buckets_get_keys_rec_fp(cons(pair(k, nat_of_int(dist)), acc), buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          long_chain_does_not_make_it_to_keys(k, dist - 1,
                                              advance_acc(atb), t);
          nat ndist = nat_of_int(dist);
          switch(ndist) {
            case zero:
              assert int_of_nat(nat_of_int(dist)) == dist;
              assert length(buckets) <= dist;
              assert int_of_nat(ndist) == 0;
              assert dist == 0;
              lt_and_ge_false(0, length(buckets));
              assert false;
            case succ(n):
              int prev = int_of_nat(n);
              assert dist == int_of_nat(succ(n));
              assert dist == 1 + int_of_nat(n);
              assert dist == 1 + prev;
              assert prev == dist - 1;
              assert 0 < dist;
              assert nat_of_int(dist) != zero;
              assert get_current_key_fp(atb) ==
                     get_current_key_fp(cons(pair(k, nat_of_int(dist)), atb));
              assert get_current_key_fp(atb) ==
                     get_current_key_fp(acc_at_this_bucket(cons(pair(k, nat_of_int(dist)),
                                                                acc),
                                                           h));
              assert advance_acc(cons(pair(k, ndist), atb)) ==
                     cons(pair(k, n), advance_acc(atb));

          }
      }
  }
}//took 15m

lemma void cons_chain_preserve_same_wraparound<kt>(pair<kt, nat> chain,
                                                   list<pair<kt, nat> > acc1,
                                                   list<pair<kt, nat> > acc2,
                                                   list<bucket<kt> > buckets)
requires buckets_get_keys_rec_fp(acc1, buckets) ==
         buckets_get_keys_rec_fp(acc2, buckets);
ensures buckets_get_keys_rec_fp(cons(chain, acc1), buckets) ==
        buckets_get_keys_rec_fp(cons(chain, acc2), buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          switch(chain) {
            case pair(key, dist):
              switch(dist) {
                case zero:
                case succ(n):
                  cons_chain_preserve_same_wraparound(pair(key, n),
                                                      advance_acc(atb1),
                                                      advance_acc(atb2),
                                                      t);
              }
          }
      }
  }
}//took 3m

lemma void filter_acc_cut_wraparound_same_keys<kt>(list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets)
requires true;
ensures buckets_get_keys_rec_fp(acc, buckets) ==
        buckets_get_keys_rec_fp(filter((sup)((nat_lt)(length(buckets)), snd), acc),
                                buckets);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          filter_acc_cut_wraparound_same_keys(t, buckets);
          if ((sup)((nat_lt)(length(buckets)), snd)(h)) {
            cons_chain_preserve_same_wraparound(h, t,
                                                filter((sup)((nat_lt)
                                                             (length(buckets)),
                                                             snd), t),
                                                buckets);
          } else {
            long_chain_does_not_make_it_to_keys(key, int_of_nat(dist),
                                                t, buckets);
          }
      }
  }
}//took 26m

lemma void keep_short_indeed_short<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == buckets_short_fp(keep_short_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          filter_forall((sup)((nat_lt)(length(buckets)), snd), chains);
          keep_short_same_len(buckets);
          keep_short_indeed_short(t);
      }
  }
}//took 3m

lemma void filter_long_chains_same_cur_key<kt>(list<pair<kt, nat> > acc,
                                               int cutoff)
requires 0 < cutoff;
ensures get_current_key_fp(acc) ==
        get_current_key_fp(filter((sup)((nat_lt)(cutoff), snd), acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              filter_long_chains_same_cur_key(t, cutoff);
          }
      }
  }
}

lemma void buckets_short_get_keys_rec<kt>(list<pair<kt, nat> > acc,
                                          list<bucket<kt> > buckets)
requires true;
ensures buckets_get_keys_rec_fp(acc, buckets) ==
        buckets_get_keys_rec_fp(acc, keep_short_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > filter_acc =
      filter((sup)((nat_lt)(length(buckets)), snd), acc);
      filter_acc_cut_wraparound_same_keys(acc, buckets);
      filter_acc_cut_wraparound_same_keys(acc, keep_short_fp(buckets));
      keep_short_same_len(buckets);
      filter_forall((sup)((nat_lt)(length(buckets)), snd), acc);

      list<pair<kt, nat> > atb = acc_at_this_bucket(filter_acc, h);
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > short_atb =
          append(filter_acc, filter((sup)((nat_lt)(length(buckets)), snd), chains));
          filter_append_idemp(filter_acc, chains, (sup)((nat_lt)(length(buckets)), snd));
          filter_forall((sup)((nat_lt)(length(buckets)), snd), filter_acc);
          assert short_atb == filter((sup)((nat_lt)(length(buckets)), snd), atb);
          filter_long_chains_same_cur_key(atb, length(buckets));
          assert get_current_key_fp(atb) ==
                 get_current_key_fp(short_atb);
          filter_acc_cut_wraparound_same_keys(advance_acc(atb), t);
          advance_acc_cutoff_swap(atb, length(buckets));
          assert buckets_get_keys_rec_fp(advance_acc(atb), t) ==
                 buckets_get_keys_rec_fp(advance_acc(short_atb), t);
          buckets_short_get_keys_rec(advance_acc(short_atb), t);
      }
  }
}//took 30m


lemma void nonmem_map_append_filter<t1,t2>(fixpoint (t1,t2) f1,
                                           fixpoint (t1,bool) f2,
                                           list<t1> l,
                                           list<t1> l2,
                                           t1 el)
requires false == mem(f1(el), map(f1, append(l, l2)));
ensures false == mem(f1(el), map(f1, append(l, filter(f2, l2))));
{
  switch(l) {
    case nil:
      nonmem_map_filter(f1, f2, l2, el);
    case cons(h,t):
      nonmem_map_append_filter(f1, f2, t, l2, el);
  }
}

lemma void distinct_map_append_filter<t1,t2>(fixpoint (t1,t2) f1,
                                             fixpoint (t1,bool) f2,
                                             list<t1> l1,
                                             list<t1> l2)
requires true == distinct(map(f1, append(l1, l2)));
ensures true == distinct(map(f1, append(l1, filter(f2, l2))));
{
  switch(l1) {
    case nil:
      distinct_map_filter(f1, f2, l2);
    case cons(h,t):
      distinct_map_append_filter(f1, f2, t, l2);
      assert true == distinct(map(f1, append(t, filter(f2, l2))));
      assert false == mem(f1(h), map(f1, append(t, l2)));
      nonmem_map_append_filter(f1, f2, t, l2, h);
      assert false == mem(f1(h), map(f1, append(t, filter(f2, l2))));
  }
}

lemma void advance_acc_dec_nonmem<kt>(nat n, list<pair<kt, nat> > acc)
requires false == mem(succ(n), map(snd, acc));
ensures false == mem(n, map(snd, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(m):
          }
          advance_acc_dec_nonmem(n, t);
      }
  }
}

lemma void advance_acc_still_distinct<kt>(list<pair<kt, nat> > acc)
requires true == distinct(map(snd, acc));
ensures true == distinct(map(snd, advance_acc(acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
              advance_acc_dec_nonmem(n, t);
              assert false == mem(n, map(snd, advance_acc(t)));
          }
          advance_acc_still_distinct(t);
      }
  }
}

lemma void buckets_ok_short_long_ok_rec<kt>(list<pair<kt, nat> > acc1,
                                            list<pair<kt, nat> > acc2,
                                            list<pair<kt, nat> > acc,
                                            list<bucket<kt> > buckets,
                                            int bound)
requires true == subset(acc1, acc) &*&
         true == subset(acc2, acc) &*&
         true == distinct(map(snd, acc1)) &*&
         true == distinct(map(snd, acc2)) &*&
         true == buckets_ok_rec(acc, buckets, bound);
ensures true == buckets_ok_rec(acc1, keep_short_fp(buckets), bound) &*&
        true == buckets_ok_rec(acc2, keep_long_fp(buckets), bound);
{
  switch(buckets) {
    case nil:
      subset_forall(acc1, acc, (sup)((nat_lt)(bound - 1), snd));
      subset_forall(acc2, acc, (sup)((nat_lt)(bound - 1), snd));
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 =
          append(acc1, filter((sup)((nat_lt)(length(buckets)), snd), chains));
          list<pair<kt, nat> > atb2 =
          append(acc2, filter((sup)((nat_ge)(length(buckets)), snd), chains));
          filter_subset((sup)((nat_lt)(length(buckets)), snd), chains);
          filter_subset((sup)((nat_ge)(length(buckets)), snd), chains);
          append_both_subset(acc1, chains, acc);
          assert true == subset(append(acc1, chains), atb);
          append_both_subset(filter((sup)((nat_lt)(length(buckets)), snd), chains),
                             acc1,
                             chains);
          subset_trans(atb1, append(acc1, chains), atb);
          assert true == subset(atb1, append(acc1, chains));
          assert true == subset(atb1, atb);
          append_both_subset(acc2, chains, acc);
          append_both_subset(filter((sup)((nat_ge)(length(buckets)), snd), chains),
                             acc2,
                             chains);
          subset_trans(atb2, append(acc2, chains), atb);
          assert true == subset(atb2, atb);
          map_append(snd, acc1, filter((sup)((nat_lt)(length(buckets)), snd),
                                       chains));
          map_append(snd, acc2, filter((sup)((nat_ge)(length(buckets)), snd),
                                       chains));
          map_append(snd, acc, filter((sup)((nat_lt)(length(buckets)), snd),
                                      chains));
          map_append(snd, acc, filter((sup)((nat_ge)(length(buckets)), snd),
                                      chains));
          map_append(snd, acc, chains);
          subset_map(acc1, acc, snd);
          subset_map(acc2, acc, snd);
          distinct_map_append_filter(snd,
                                     (sup)((nat_lt)(length(buckets)), snd),
                                     acc, chains);
          distinct_map_append_filter(snd,
                                     (sup)((nat_ge)(length(buckets)), snd),
                                     acc, chains);
          subset_append_distinct(map(snd, acc1),
                                 map(snd, acc),
                                 map(snd, filter((sup)((nat_lt)(length(buckets)), snd),
                                                 chains)));
          subset_append_distinct(map(snd, acc2),
                                 map(snd, acc),
                                 map(snd, filter((sup)((nat_ge)(length(buckets)), snd),
                                                 chains)));
          assert true == distinct(map(snd, atb1));
          assert true == distinct(map(snd, atb2));
          subset_forall(atb1, atb, (sup)((nat_lt)(bound), snd));
          subset_forall(atb2, atb, (sup)((nat_lt)(bound), snd));
          advance_acc_still_distinct(atb1);
          advance_acc_still_distinct(atb2);
          advance_acc_subset(atb1, atb);
          advance_acc_subset(atb2, atb);

          buckets_ok_short_long_ok_rec(advance_acc(atb1),
                                       advance_acc(atb2),
                                       advance_acc(atb),
                                       t, bound);
      }

  }
}

lemma void buckets_ok_short_long_ok<kt>(list<pair<kt, nat> > acc,
                                        list<bucket<kt> > buckets,
                                        int bound)
requires true == buckets_ok_rec(acc, buckets, bound);
ensures true == buckets_ok_rec(acc,
                               keep_short_fp(buckets),
                               bound) &*&
        true == buckets_ok_rec(acc,
                               keep_long_fp(buckets),
                               bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          map_append(snd, acc, chains);
          distinct_unappend(map(snd, acc), map(snd, chains));
          assert true == distinct(map(snd, acc));
      }
  }
  buckets_ok_short_long_ok_rec(acc, acc, acc, buckets, bound);
}//took 50m

lemma void deadvance_acc_key_mem<kt>(list<pair<kt, nat> > acc, kt k)
requires true == mem(k, map(fst, advance_acc(acc)));
ensures true == mem(k, map(fst, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
          if (mem(k, map(fst, advance_acc(t)))) {
            deadvance_acc_key_mem(t, k);
          } else {
            assert key == k;
            assert dist != zero;
          }
      }
  }
}//took 3m

lemma void current_key_mem<kt>(list<pair<kt, nat> > acc, kt k)
requires get_current_key_fp(acc) == some(k);
ensures true == mem(k, map(fst, acc));
{
  if (!mem(k, map(fst, acc))) {
    no_key_certainly_not_here(acc, k);
  }
}

lemma void start_after_end_in_acc<kt>(list<pair<kt, nat> > acc,
                                      list<bucket<kt> > buckets,
                                      kt k, int start, int x)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         0 <= x &*& x < start &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == some(k) &*&
         true == distinct(buckets_all_keys_fp(buckets));
ensures true == mem(k, map(fst, acc));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          buckets_distinct_all_keys_breakdown(chains, t);
          distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                            chains, t);
          map_append(fst, acc, chains);
          if (x == 0) {
            assert get_current_key_fp(atb) == some(k);
            current_key_mem(atb, k);
          } else {
            start_after_end_in_acc(advance_acc(atb),
                                   t, k, start - 1, x - 1);
            deadvance_acc_key_mem(atb, k);
          }
      }
  }
}

lemma void advance_acc_still_unique<kt>(list<pair<kt, nat> > acc, kt k)
requires false == mem(k, remove(k, map(fst, acc)));
ensures false == mem(k, remove(k, map(fst, advance_acc(acc))));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              if (k == key) {
                advance_acc_still_no_key(t, k);
                remove_nonmem(k, map(fst, advance_acc(t)));
              } else {
                advance_acc_still_unique(t, k);
              }
            case succ(n):
              if (k == key) {
                advance_acc_still_no_key(t, k);
              } else {
                advance_acc_still_unique(t, k);
              }
          }
      }
  }
}//took 15m

lemma void no_chain_whatsoever_no_key_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                                        list<bucket<kt> > buckets,
                                                        kt k)
requires false == mem(k, buckets_all_keys_fp(buckets)) &*&
         false == mem(k, map(fst, acc));
ensures false == mem(k, map(fst, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          map_append(fst, acc, chains);
          advance_acc_still_no_key(atb, k);
          no_chain_whatsoever_no_key_in_wraparound(advance_acc(atb),
                                                   t, k);
      }
  }
}

lemma void see_chain_end_no_key_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets,
                                                  kt k, int x)
requires false == mem(k, buckets_all_keys_fp(buckets)) &*&
         false == mem(k, remove(k, map(fst, acc))) &*&
         0 <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == some(k);
ensures false == mem(k, map(fst, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          map_append(fst, acc, chains);
          assert false == mem(k, map(fst, chains));
          remove_append_swap(k, map(fst, acc),
                             map(fst, chains));
          if (mem(k, map(fst, acc))) {
            assert remove(k, map(fst, atb)) ==
                   append(remove(k, map(fst, acc)),
                          map(fst, chains));
            assert false == mem(k, remove(k, map(fst, acc)));
            assert false == mem(k, remove(k, map(fst, atb)));
          } else {
            assert remove(k, map(fst, atb)) ==
                   append(map(fst, acc),
                          remove(k, map(fst, chains)));
            if (mem(k, remove(k, map(fst, chains)))) {
              mem_remove_mem(k, k, map(fst, chains));
            }
            assert false == mem(k, remove(k, map(fst, chains)));
            assert false == mem(k, remove(k, map(fst, atb)));
          }
          if (0 == x) {
            assert get_current_key_fp(atb) == some(k);
            current_key_pair_zero(atb, k);
            assert true == mem(pair(k, zero), atb);
            advance_last_chain_with_zero_nonmem(atb, k);
            no_chain_whatsoever_no_key_in_wraparound(advance_acc(atb),
                                                     t, k);
          } else {
            advance_acc_still_unique(atb, k);
            see_chain_end_no_key_in_wraparound(advance_acc(atb),
                                               t, k, x - 1);
          }
      }
  }
}

lemma void no_long_chain_not_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                               list<bucket<kt> > buckets,
                                               kt k, int start, int x)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         start <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == some(k) &*&
         false == mem(k, map(fst, acc)) &*&
         true == distinct(buckets_all_keys_fp(buckets));
ensures false == mem(k, map(fst, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          buckets_distinct_all_keys_breakdown(chains, t);
          map_append(fst, acc, chains);
          if (start == 0) {
            distinct_key_in_here_not_in_the_following(k, chains, t);
            assert false == mem(k, buckets_all_keys_fp(t));
            assert true == mem(k, map(fst, atb));
            assert false == mem(k, map(fst, acc));
            assert true == distinct(map(fst, chains));
            distinct_unique(map(fst, chains), k);
            assert false == mem(k, remove(k, map(fst, chains)));
            remove_append_swap(k, map(fst, acc),
                               map(fst, chains));
            assert false == mem(k, remove(k, map(fst, atb)));
            advance_acc_still_unique(atb, k);
            if (0 < x) {
              see_chain_end_no_key_in_wraparound(advance_acc(atb),
                                                 t, k, x - 1);
            } else {
              assert get_current_key_fp(atb) == some(k);
              current_key_pair_zero(atb, k);
              assert true == mem(pair(k, zero), atb);
              advance_last_chain_with_zero_nonmem(atb, k);
              no_chain_whatsoever_no_key_in_wraparound(advance_acc(atb),
                                                       t, k);
            }
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            advance_acc_still_no_key(atb, k);
            no_long_chain_not_in_wraparound(advance_acc(atb),
                                            t, k, start - 1, x - 1);
          }
      }
  }
}

lemma void chain_ends_early_not_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets,
                                                  kt k, int start, int x,
                                                  int dist)
requires 0 <= start &*& start < length(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets)) &*&
         start <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == some(k) &*&
         true == mem(pair(k, nat_of_int(dist)), acc) &*&
         0 <= dist &*& dist < start &*&
         false == mem(k, remove(k, map(fst, acc))) &*&
         true == distinct(buckets_all_keys_fp(buckets));
ensures false == mem(k, map(fst, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          buckets_distinct_all_keys_breakdown(chains, t);
          map_append(fst, acc, chains);
          if (start == 0) {
          } else {
            distinct_key_in_following_not_in_the_first_bucket(k, start - 1,
                                                              chains, t);
            mem_map(pair(k, nat_of_int(dist)), acc, fst);
            remove_append_swap(k, map(fst, acc), map(fst, chains));
            if (dist == 0) {
              advance_last_chain_with_zero_nonmem(atb, k);
              no_long_chain_not_in_wraparound(advance_acc(atb), t,
                                              k, start - 1, x - 1);
              return;
            }
            mem_advance_acc_swap(atb, k, nat_of_int(dist - 1));
            assert false == mem(k, remove(k, map(fst, acc)));
            assert false == mem(k, map(fst, chains));
            assert true == mem(k, map(fst, acc));
            assert map(fst, atb) == append(map(fst, acc), map(fst, chains));
            assert remove(k, map(fst, atb)) ==
                   append(remove(k, map(fst, acc)),
                          map(fst, chains));
            assert false == mem(k, remove(k, map(fst, atb)));
            advance_acc_still_unique(atb, k);
            assert false == mem(k, remove(k, map(fst, advance_acc(atb))));
            chain_ends_early_not_in_wraparound(advance_acc(atb), t,
                                               k, start - 1, x - 1,
                                               dist - 1);
          }
      }
  }
}

lemma void buckets_chain_end<kt>(list<bucket<kt> > buckets, kt k,
                                 int start, int i, int capacity)
requires nth(loop_fp(start + i, capacity),
             buckets_get_keys_fp(buckets)) ==
         some(k) &*&
         0 <= start &*& start < capacity &*&
         0 <= i &*& i < capacity &*&
         0 < capacity &*& length(buckets) == capacity &*&
         true == buckets_ok(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures buckets_get_chain_fp(buckets, k, start) == i;
{
  int real_value = buckets_get_chain_fp(buckets, k, start);
  list<bucket<kt> > low = keep_short_fp(buckets);
  list<bucket<kt> > high = keep_long_fp(buckets);
  keep_long_same_wraparound(nil, buckets);
  assert get_wraparound(nil, buckets) ==
         get_wraparound(nil, high);
  keep_long_indeed_long(buckets);
  long_buckets_all_keys_in_wraparound(high);
  assert true == multiset_eq(map(fst, get_wraparound(nil, high)),
                             buckets_all_keys_fp(high));
  buckets_split_all_keys(buckets);
  assert true == multiset_eq(append(buckets_all_keys_fp(low),
                                    buckets_all_keys_fp(high)),
                             buckets_all_keys_fp(buckets));
  multiset_eq_distinct(append(buckets_all_keys_fp(low),
                              buckets_all_keys_fp(high)),
                       buckets_all_keys_fp(buckets));
  distinct_unappend(buckets_all_keys_fp(low),
                    buckets_all_keys_fp(high));

  assert true == disjoint(buckets_all_keys_fp(high),
                          buckets_all_keys_fp(low));
  disjoint_mem(buckets_all_keys_fp(high),
               buckets_all_keys_fp(low),
               k);
  if (mem(k, buckets_all_keys_fp(low))) {
    assert false == mem(k, buckets_all_keys_fp(high));
    if (capacity <= start + real_value) {
      long_chain_in_keep_long(buckets, k, start);
      assert true == bucket_has_key_fp(k, nth(start, high));
      assert true == mem(k, buckets_all_keys_fp(high));
      assert false;
    }
    assert start + real_value < capacity;
    assert false == mem(k, buckets_all_keys_fp(high));
    multiset_eq_mem(k, map(fst, get_wraparound(nil, high)),
                    buckets_all_keys_fp(high));
    assert false == mem(k, map(fst, get_wraparound(nil, high)));
    assert false == mem(k, map(fst, get_wraparound(nil, buckets)));
    if (capacity <= start + i) {
      loop_injection_n(start + i - capacity, capacity, 1);
      loop_bijection(start + i - capacity, capacity);
      start_after_end_in_acc(get_wraparound(nil, buckets),
                             buckets, k, start, start + i - capacity);
      assert false;
    }
    loop_bijection(start + i, capacity);
    buckets_chain_end_rec(get_wraparound(nil, buckets),
                          buckets,
                          k, start, i,
                          capacity);
    assert real_value == i;
  } else {
    bucket_has_key_mem_all_keys(k, start, buckets);
    assert false == mem(k, buckets_all_keys_fp(low));
    if (!mem(k, buckets_all_keys_fp(high))) {
      assert true == mem(k, buckets_all_keys_fp(buckets));
      multiset_eq_comm(append(buckets_all_keys_fp(low),
                              buckets_all_keys_fp(high)),
                       buckets_all_keys_fp(buckets));
      multiset_eq_mem(k, buckets_all_keys_fp(buckets),
                      append(buckets_all_keys_fp(low),
                             buckets_all_keys_fp(high)));
      mem_append(k, buckets_all_keys_fp(low),
                 buckets_all_keys_fp(high));
      assert false;
    }
    assert true == mem(k, buckets_all_keys_fp(high));
    multiset_eq_mem(k, map(fst, get_wraparound(nil, high)),
                    buckets_all_keys_fp(high));
    if (start + real_value < capacity) {
      short_chain_in_keep_short(buckets, k, start);
      assert true == bucket_has_key_fp(k, nth(start, low));
      assert true == mem(k, buckets_all_keys_fp(low));
      assert false;
    }
    assert capacity <= start + real_value;
    buckets_ok_get_chain_bounded(buckets, k, start);
    bucket_has_key_in_wraparound_rec(buckets, nil, k, start, real_value);
    assert true == mem(pair(k, nat_of_int(start + real_value - capacity)),
                       get_wraparound(nil, buckets));
    if (start + i < capacity) {
      loop_bijection(start + i, capacity);
      buckets_keys_distinct_wraparound_too(buckets);
      distinct_unique(map(fst, get_wraparound(nil, buckets)), k);
      chain_ends_early_not_in_wraparound(get_wraparound(nil, buckets),
                                         buckets,
                                         k, start, start + i,
                                         start + real_value - capacity);
      buckets_ok_get_wraparound_idemp(buckets);
      assert false;
    }
    assert capacity <= start + i;
    loop_injection_n(start + i - capacity, capacity, 1);
    loop_bijection(start + i - capacity, capacity);

    buckets_short_get_keys_rec(get_wraparound(nil, buckets), buckets);
    keep_short_same_len(buckets);
    buckets_ok_short_long_ok(get_wraparound(nil, buckets),
                             buckets, capacity);
    acc_chain_end_rec(get_wraparound(nil, buckets),
                      low, k, start + i - capacity,
                      capacity);
    assert true == mem(pair(k, nat_of_int(start + i - capacity)),
                       get_wraparound(nil, buckets));
    buckets_keys_distinct_wraparound_too(buckets);
    distinct_map_identical_elems(fst, get_wraparound(nil, buckets),
                                 pair(k, nat_of_int(start + i - capacity)),
                                 pair(k, nat_of_int(start + real_value - capacity)));
    assert start + i - capacity == int_of_nat(nat_of_int(start + i - capacity));
    assert start + real_value - capacity ==
           int_of_nat(nat_of_int(start + i - capacity));
    assert real_value == i;
  }
}

lemma void chns_after_partial_chain_ended<kt>(list<bucket<kt> > buckets, kt k,
                                              int start, int i,
                                              int capacity)
requires nth(loop_fp(start + i, capacity),
             buckets_get_keys_fp(buckets)) ==
         some(k) &*&
         0 <= start &*& start < capacity &*&
         0 <= i &*& i < capacity &*&
         length(buckets) == capacity &*& 0 < capacity &*&
         true == buckets_ok(buckets) &*&
         true == bucket_has_key_fp(k, nth(start, buckets));
ensures buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)) ==
        add_partial_chain_fp
        (loop_fp(start + i, capacity),
         buckets_get_chain_fp(buckets, k, start) - i,
         buckets_get_chns_fp(buckets_remove_key_fp(buckets,
                                                   k)));
{
  buckets_chain_end(buckets, k, start, i, capacity);
  assert buckets_get_chain_fp(buckets, k, start) == i;
  loop_lims(start + i, capacity);
  buckets_remove_key_same_len(buckets, k);
  buckets_keys_chns_same_len(buckets_remove_key_fp(buckets, k));
  add_part_chn_zero_len
  (buckets_get_chns_fp(buckets_remove_key_fp(buckets, k)),
   loop_fp(start + i, capacity));
} //took 25m


lemma void buckets_ok_rec_acc_tails_distinct<kt>(list<pair<kt, nat> > acc,
                                                 list<bucket<kt> > buckets,
                                                 int bound)
requires true == buckets_ok_rec(acc, buckets, bound);
ensures true == distinct(map(snd, acc));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          map_append(snd, acc, chains);
          distinct_unappend(map(snd, acc), map(snd, chains));
      }
  }
}


lemma void acc_subset_buckets_still_ok_rec<kt>(list<pair<kt, nat> > acc1,
                                               list<pair<kt, nat> > acc2,
                                               list<bucket<kt> > buckets,
                                               int bound)
requires true == subset(acc1, acc2) &*&
         true == distinct(map(snd, acc1)) &*&
         true == buckets_ok_rec(acc2, buckets, bound);
ensures true == buckets_ok_rec(acc1, buckets, bound);
{
  switch(buckets) {
    case nil:
      assert true == distinct(map(snd, acc1));
      subset_forall(acc1, acc2, (sup)((nat_lt)(bound - 1), snd));
    case cons(h,t):
      acc_at_this_bucket_subset(acc1, acc2, h);
      assert true == subset(acc_at_this_bucket(acc1, h),
                            acc_at_this_bucket(acc2, h));
      advance_acc_subset(acc_at_this_bucket(acc1, h),
                         acc_at_this_bucket(acc2, h));
      assert true == subset(advance_acc(acc_at_this_bucket(acc1, h)),
                            advance_acc(acc_at_this_bucket(acc2, h)));
      switch(h) {
        case bucket(chains):
          map_append(snd, acc2, chains);
          assert true == distinct(append(map(snd, acc2),
                                         map(snd, chains)));
          subset_map(acc1, acc2, snd);
          subset_append_distinct(map(snd, acc1),
                                 map(snd, acc2),
                                 map(snd, chains));
          map_append(snd, acc1, chains);
          assert true == distinct(map(snd, append(acc1, chains)));
      }
    assert true == distinct(map(snd, acc_at_this_bucket(acc2, h)));
    assert true == distinct(map(snd, acc_at_this_bucket(acc1, h)));
    subset_forall(acc_at_this_bucket(acc1, h),
                  acc_at_this_bucket(acc2, h), (sup)((nat_lt)(bound), snd));
    advance_acc_still_distinct(acc_at_this_bucket(acc1, h));
    acc_subset_buckets_still_ok_rec
    (advance_acc(acc_at_this_bucket(acc1, h)),
     advance_acc(acc_at_this_bucket(acc2, h)),
     t, bound);

  }
}

lemma void buckets_remove_key_still_ok_rec<kt>(list<pair<kt, nat> > acc,
                                               list<bucket<kt> > buckets,
                                               kt k,
                                               int bound)
requires true == buckets_ok_rec(acc, buckets, bound);
ensures true == buckets_ok_rec(acc, buckets_remove_key_fp(buckets, k), bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_acc_atb =
          append(acc, filter((not_this_key_pair_fp)(k), chains));
          filter_subset((not_this_key_pair_fp)(k), chains);
          append_both_subset(filter((not_this_key_pair_fp)(k), chains),
                             acc, chains);
          assert true == subset(new_acc_atb, acc_atb);
          advance_acc_subset(new_acc_atb, acc_atb);
          assert true == subset(advance_acc(new_acc_atb) ,
                                advance_acc(acc_atb));
          distinct_map_append_filter(snd, (not_this_key_pair_fp)(k),
                                     acc, chains);
          assert true == distinct(map(snd, new_acc_atb));
          subset_forall(new_acc_atb, acc_atb, (sup)((nat_lt)(bound), snd));
          assert true == forall(new_acc_atb, (sup)((nat_lt)(bound), snd));
          assert true == buckets_ok_rec(advance_acc(acc_atb), t, bound);
          advance_acc_still_distinct(new_acc_atb);
          acc_subset_buckets_still_ok_rec(advance_acc(new_acc_atb),
                                          advance_acc(acc_atb),
                                          t,
                                          bound);
          assert true == buckets_ok_rec(advance_acc(new_acc_atb), t, bound);
          buckets_remove_key_still_ok_rec(advance_acc(new_acc_atb),
                                          t, k, bound);
      }
  }
}

lemma void remkey_advance_acc_idemp<kt>(list<pair<kt, nat> > acc,
                                        kt k)
requires true;
ensures filter((not_this_key_pair_fp)(k), advance_acc(acc)) ==
        advance_acc(filter((not_this_key_pair_fp)(k), acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      remkey_advance_acc_idemp(t, k);
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
  }
}

lemma void get_wraparound_removed_key<kt>(list<pair<kt, nat> > acc,
                                          list<bucket<kt> > buckets,
                                          kt k)
requires true;
ensures get_wraparound(filter((not_this_key_pair_fp)(k), acc),
                       buckets_remove_key_fp(buckets, k)) ==
        filter((not_this_key_pair_fp)(k), get_wraparound(acc, buckets));
{
  switch(buckets) {
    case nil:
      assert nil == buckets_remove_key_fp(buckets, k);
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > new_chains = filter((not_this_key_pair_fp)(k), chains);
          bucket<kt> new_h = bucket(new_chains);
          get_wraparound_removed_key(advance_acc(acc_at_this_bucket(acc, h)),
                                     t, k);

          filter_append_idemp(acc, chains, (not_this_key_pair_fp)(k));
          remkey_advance_acc_idemp(acc_at_this_bucket(acc, h), k);
      }
  }
}

lemma void buckets_ok_rec_wraparound_distinct<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets,
                                                  int bound)
requires true == buckets_ok_rec(acc, buckets, bound);
ensures true == distinct(map(snd, get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_ok_rec_wraparound_distinct
      (advance_acc(acc_at_this_bucket(acc, h)),
       t, bound);
  }
}

lemma void acc_remove_key_buckets_still_ok_rec<kt>(list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets,
                                                   kt k, int bound)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         true == distinct(map(snd, acc));
ensures true == buckets_ok_rec(filter((not_this_key_pair_fp)(k), acc),
                               buckets, bound);
{
  filter_subset((not_this_key_pair_fp)(k), acc);
  distinct_map_filter(snd, (not_this_key_pair_fp)(k), acc);
  acc_subset_buckets_still_ok_rec(filter((not_this_key_pair_fp)(k), acc),
                                  acc, buckets, bound);
}

lemma void buckets_remove_key_keys_msubset<kt>(list<bucket<kt> > buckets, kt k)
requires true;
ensures true == msubset(buckets_all_keys_fp(buckets_remove_key_fp(buckets, k)),
                        buckets_all_keys_fp(buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          buckets_remove_key_keys_msubset(t, k);
          filter_msubset((not_this_key_pair_fp)(k), chains);
          msubset_map(fst, filter((not_this_key_pair_fp)(k),
                                  chains),
                      chains);
          msubset_append_both(map(fst, filter((not_this_key_pair_fp)(k),
                                              chains)),
                              buckets_all_keys_fp(buckets_remove_key_fp(t, k)),
                              map(fst, chains),
                              buckets_all_keys_fp(t));
      }
  }
}//took 4m

lemma void buckets_remove_key_still_distinct<kt>(list<bucket<kt> > buckets, kt k)
requires true == distinct(buckets_all_keys_fp(buckets));
ensures true == distinct(buckets_all_keys_fp(buckets_remove_key_fp(buckets, k)));
{
  buckets_remove_key_keys_msubset(buckets, k);
  msubset_distinct(buckets_all_keys_fp(buckets_remove_key_fp(buckets, k)),
                   buckets_all_keys_fp(buckets));
}//took 10m

lemma void buckets_remove_key_still_ok<kt>(list<bucket<kt> > buckets, kt k)
requires true == buckets_ok(buckets);
ensures true == buckets_ok(buckets_remove_key_fp(buckets, k));
{
  if (buckets == nil) {
    return;
  }
  buckets_remove_key_same_len(buckets, k);
  buckets_remove_key_still_ok_rec(get_wraparound(nil, buckets), buckets,
                                  k, length(buckets));
  get_wraparound_removed_key(nil, buckets, k);
  buckets_ok_rec_wraparound_distinct(get_wraparound(nil, buckets),
                                     buckets, length(buckets));
  buckets_ok_get_wraparound_idemp(buckets);
  acc_remove_key_buckets_still_ok_rec(get_wraparound(nil, buckets),
                                      buckets_remove_key_fp(buckets, k),
                                      k, length(buckets));
  buckets_remove_key_still_distinct(buckets, k);
} //took 225m

lemma void current_key_is_mem<kt>(list<pair<kt, nat> > acc, kt k)
requires get_current_key_fp(acc) == some(k);
ensures true == mem(k, map(fst, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              current_key_is_mem(t, k);
          }
      }
  }
}

lemma void advance_acc_filter_current_key<kt>(list<pair<kt, nat> > acc,
                                              kt k)
requires true == distinct(map(fst, acc)) &*&
         get_current_key_fp(acc) == some(k);
ensures advance_acc(acc) ==
        advance_acc(filter((not_this_key_pair_fp)(k), acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
              nonmem_not_this_key(t, k);
              filter_forall((not_this_key_pair_fp)(k), t);
            case succ(n):
              advance_acc_filter_current_key(t, k);
              current_key_is_mem(t, k);
          }
      }
  }
} //took 25m

lemma void filter_affects_just_first_half<t>(list<t> l1, list<t> l2,
                                             fixpoint (t, bool) f)
requires true == forall(l2, f);
ensures filter(f, append(l1, l2)) == append(filter(f, l1), l2);
{
  filter_append_idemp(l1, l2, f);
  filter_forall(f, l2);
}//took 4m

lemma void curr_key_out_no_other_zero_chain<kt>(list<pair<kt, nat> > acc, kt k)
requires true == distinct(map(snd, acc)) &*&
         get_current_key_fp(acc) == some(k);
ensures false == mem(zero, map(snd, filter((not_this_key_pair_fp)(k), acc)));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert key == k;
              assert false == mem(zero, map(snd, t));
              nonmem_map_filter(snd, (not_this_key_pair_fp)(k), t,
                                pair(k, zero));
            case succ(n):
              curr_key_out_no_other_zero_chain(t, k);
          }

      }
  }
}//start 47

lemma void filter_other_key_curr_key_same<kt>(list<pair<kt, nat> > acc, kt k)
requires get_current_key_fp(acc) != some(k);
ensures get_current_key_fp(filter((not_this_key_pair_fp)(k), acc)) ==
        get_current_key_fp(acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(n):
              filter_other_key_curr_key_same(t, k);
          }
      }
  }
}//took 2m

lemma void acc_rm_key_buckets_get_keys_rec<kt>(list<pair<kt, nat> > acc,
                                               list<bucket<kt> > buckets,
                                               list<option<kt> > keys,
                                               kt k, int bound)
requires true == mem(some(k), keys) &*&
         true == opt_no_dups(keys) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         true == distinct(map(fst, acc)) &*&
         true == distinct(buckets_all_keys_fp(buckets)) &*&
         true == disjoint(map(fst, acc),
                          buckets_all_keys_fp(buckets)) &*&
         keys == buckets_get_keys_rec_fp(acc, buckets) &*&
         true == mem(k, map(fst, acc));
ensures buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k), acc),
                                buckets) ==
        update(index_of(some(k), keys), none, keys);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = filter((not_this_key_pair_fp)(k),
                                                acc_atb);
          buckets_distinct_all_keys_breakdown(chains, t);
          msubset_subset(map(fst, chains), buckets_all_keys_fp(buckets));
          msubset_subset(buckets_all_keys_fp(t),
                         buckets_all_keys_fp(buckets));
          disjoint_comm(map(fst, acc),
                        buckets_all_keys_fp(buckets));
          subset_disjoint(map(fst, chains), buckets_all_keys_fp(buckets),
                          map(fst, acc));
          subset_disjoint(buckets_all_keys_fp(t),
                          buckets_all_keys_fp(buckets),
                          map(fst, acc));
          disjoint_comm(map(fst, chains), map(fst, acc));
          disjoint_comm(buckets_all_keys_fp(t), map(fst, acc));
          disjoint_mem(map(fst, acc), map(fst, chains), k);
          nonmem_not_this_key(chains, k);
          filter_affects_just_first_half(acc, chains,
                                         (not_this_key_pair_fp)(k));
          assert append(filter((not_this_key_pair_fp)(k), acc),
                        chains) ==
                 new_atb;
        assert keys == cons(get_current_key_fp(acc_atb), ?kt);

        map_append(fst, acc, chains);
        distinct_and_disjoint_append(map(fst, acc),
                                     map(fst, chains));
          if (get_current_key_fp(acc_atb) == some(k)) {
            assert false == mem(some(k), kt);
            assert index_of(some(k), keys) == 0;
            assert update(index_of(some(k), keys), none, keys) == cons(none, kt);
            curr_key_out_no_other_zero_chain(acc_atb, k);
            assert false == mem(zero, map(snd, new_atb));
            nozero_no_current_key(new_atb);
            advance_acc_filter_current_key(acc_atb, k);
            assert advance_acc(acc_atb) == advance_acc(new_atb);
            return;
          } else {
            filter_other_key_curr_key_same(acc_atb, k);
            assert get_current_key_fp(new_atb) == get_current_key_fp(acc_atb);
            remkey_advance_acc_idemp(acc_atb, k);
            assert advance_acc(new_atb) == filter((not_this_key_pair_fp)(k),
                                                  advance_acc(acc_atb));
            advance_acc_preserve_distinct_keys(acc_atb);
            disjoint_append(map(fst, acc), map(fst, chains),
                            nil, buckets_all_keys_fp(t));
            advance_acc_subset_keys(acc_atb);
            subset_disjoint(map(fst, advance_acc(acc_atb)),
                            map(fst, acc_atb),
                            buckets_all_keys_fp(t));
            advance_acc_preserves_key(acc_atb, k);
            acc_rm_key_buckets_get_keys_rec
            (advance_acc(acc_atb), t, kt, k, bound);
            assert buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k), acc),
                                           buckets) ==
                   cons(get_current_key_fp(acc_atb),
                        buckets_get_keys_rec_fp(advance_acc(new_atb), t));
            assert buckets_get_keys_rec_fp(advance_acc(new_atb), t) ==
                   buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k),
                                                  advance_acc(acc_atb)), t);
          }
      }
  }
}//took 25m + 20m + 30m

lemma void buckets_rm_nonexisting_key_get_keys<kt>(list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets,
                                                   list<option<kt> > keys,
                                                   kt k)
requires false == mem(some(k), keys) &*&
         keys == buckets_get_keys_rec_fp(acc, buckets);
ensures buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k),
                                       acc), buckets_remove_key_fp(buckets, k)) ==
        keys;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = filter((not_this_key_pair_fp)(k), atb);
          filter_append_idemp(acc, chains, (not_this_key_pair_fp)(k));
          filter_other_key_curr_key_same(atb, k);
          buckets_rm_nonexisting_key_get_keys(advance_acc(atb),
                                              t, tail(keys), k);
          remkey_advance_acc_idemp(atb, k);
      }
  }
  
}//took 4m

lemma void buckets_rm_key_get_keys_rec<kt>(list<pair<kt, nat> > acc,
                                           list<bucket<kt> > buckets,
                                           list<option<kt> > keys,
                                           kt k,
                                           int bnd)
requires true == mem(some(k), keys) &*&
         true == opt_no_dups(keys) &*&
         keys == buckets_get_keys_rec_fp(acc, buckets) &*&
         true == buckets_ok_rec(acc, buckets, bnd);
ensures buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k),
                                       acc),
                                buckets_remove_key_fp(buckets, k)) ==
        update(index_of(some(k), keys), none, keys);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = filter((not_this_key_pair_fp)(k), atb);
          filter_append_idemp(acc, chains, (not_this_key_pair_fp)(k));
          switch(keys) {
            case nil:
              assert false;
            case cons(kh,kt):
              if (kh == some(k)) {
                assert false == mem(some(k), kt);
                buckets_rm_nonexisting_key_get_keys(advance_acc(atb),
                                                    t, kt, k);

                curr_key_out_no_other_zero_chain(atb, k);
                nozero_no_current_key(new_atb);
                remkey_advance_acc_idemp(atb, k);
              } else {
                filter_other_key_curr_key_same(atb, k);
                assert true == mem(some(k), kt);
                remkey_advance_acc_idemp(atb, k);
                buckets_rm_key_get_keys_rec(advance_acc(atb),
                                            t, kt, k, bnd);
              }
          }
      }
  }
}//took 59m

lemma void rem_key_filter_from_wraparound<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets,
                                              kt k)
requires true;
ensures get_wraparound(filter((not_this_key_pair_fp)(k),
                              acc), buckets_remove_key_fp(buckets, k)) ==
        filter((not_this_key_pair_fp)(k), get_wraparound(acc, buckets));
{
  switch(buckets) {
    case nil:
      filter_forall((not_this_key_pair_fp)(k), acc);
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > new_atb = filter((not_this_key_pair_fp)(k),
                                                atb);
          rem_key_filter_from_wraparound(advance_acc(atb), t, k);
          remkey_advance_acc_idemp(atb, k);
          filter_append_idemp(acc, chains, (not_this_key_pair_fp)(k));
      }
  }
}//took 36m

lemma void no_chain_make_it_to_wraparound_rem_safe<kt>(list<bucket<kt> > buckets,
                                                       kt k)
requires true == forall(get_wraparound(nil, buckets),
                        (not_this_key_pair_fp)(k));
ensures get_wraparound(nil, buckets) ==
        get_wraparound(nil, buckets_remove_key_fp(buckets, k));
{
  rem_key_filter_from_wraparound(nil, buckets, k);
  filter_forall((not_this_key_pair_fp)(k),
                get_wraparound(nil, buckets));
}

lemma void not_forall_not_this_mem<kt>(list<pair<kt, nat> > acc, kt k)
requires false == forall(acc, (not_this_key_pair_fp)(k));
ensures true == mem(k, map(fst, acc));
{
  if (!mem(k, map(fst, acc))) {
    nonmem_not_this_key(acc, k);
  }
}//took 2m

lemma void buckets_rm_key_get_keys<kt>(list<bucket<kt> > buckets,
                                       kt k)
requires true == mem(some(k), buckets_get_keys_fp(buckets)) &*&
         true == opt_no_dups(buckets_get_keys_fp(buckets)) &*&
         true == buckets_ok(buckets);
ensures buckets_get_keys_fp(buckets_remove_key_fp(buckets, k)) ==
        update(index_of(some(k), buckets_get_keys_fp(buckets)),
               none, buckets_get_keys_fp(buckets));
{
  list<pair<kt, nat> > wrp = get_wraparound(nil, buckets);
  list<pair<kt, nat> > nwrp = get_wraparound(nil, buckets_remove_key_fp(buckets, k));
  if (forall(wrp, (not_this_key_pair_fp)(k))) {
    no_chain_make_it_to_wraparound_rem_safe(buckets, k);
    assert wrp == nwrp;
    filter_forall((not_this_key_pair_fp)(k), wrp);
    buckets_rm_key_get_keys_rec(wrp, buckets,
                                buckets_get_keys_fp(buckets),
                                k, length(buckets));
  } else {
    buckets_keys_distinct_wraparound_too(buckets);
    buckets_ok_get_wraparound_idemp(buckets);
    list<bucket<kt> > low = keep_short_fp(buckets);
    list<bucket<kt> > high = keep_long_fp(buckets);
    keep_long_same_wraparound(nil, buckets);
    buckets_split_all_keys(buckets);
    keep_long_indeed_long(buckets);
    keep_short_indeed_short(buckets);
    multiset_eq_distinct(append(buckets_all_keys_fp(low),
                                buckets_all_keys_fp(high)),
                         buckets_all_keys_fp(buckets));
    distinct_unappend(buckets_all_keys_fp(low),
                      buckets_all_keys_fp(high));
    disjoint_comm(buckets_all_keys_fp(high),
                  buckets_all_keys_fp(low));
    disjoint_mem(buckets_all_keys_fp(high),
                 buckets_all_keys_fp(low),
                 k);
    assert wrp == get_wraparound(nil, high);
    not_forall_not_this_mem(wrp, k);
    assert true == mem(k, map(fst, wrp));
    assert true == mem(k, map(fst, get_wraparound(nil, high)));
    long_buckets_all_keys_in_wraparound(high);
    multiset_eq_mem(k, map(fst, get_wraparound(nil, high)),
                    buckets_all_keys_fp(high));
    assert true == mem(k, buckets_all_keys_fp(high));
    assert false == mem(k, buckets_all_keys_fp(low));
    buckets_short_get_keys_rec(wrp, buckets);
    buckets_ok_short_long_ok(wrp, buckets, length(buckets));
    assert true == disjoint(buckets_all_keys_fp(low),
                            buckets_all_keys_fp(high));
    multiset_eq_subset(map(fst, get_wraparound(nil, high)),
                       buckets_all_keys_fp(high));
    subset_disjoint(map(fst, get_wraparound(nil, high)),
                    buckets_all_keys_fp(high),
                    buckets_all_keys_fp(low));
    assert true == disjoint(map(fst, get_wraparound(nil, high)),
                            buckets_all_keys_fp(low));
    assert true == disjoint(map(fst, wrp),
                            buckets_all_keys_fp(low));
    acc_rm_key_buckets_get_keys_rec(wrp,
                                    low,
                                    buckets_get_keys_fp(buckets),
                                    k, length(buckets));
    rem_key_filter_from_wraparound(nil, buckets, k);
    assert nwrp ==
           filter((not_this_key_pair_fp)(k), wrp);
    buckets_short_get_keys_rec(nwrp, buckets);
    assert buckets_get_keys_rec_fp(nwrp, buckets) ==
           buckets_get_keys_rec_fp(nwrp, low);
    buckets_remove_nonexistent_key(low, k);
    assert buckets_get_keys_rec_fp(nwrp, low) ==
           buckets_get_keys_rec_fp(nwrp, buckets_remove_key_fp(low, k));
    keep_short_remove_key_swap(buckets, k);
    assert buckets_get_keys_rec_fp(nwrp, buckets_remove_key_fp(low, k)) ==
           buckets_get_keys_rec_fp(nwrp, keep_short_fp(buckets_remove_key_fp(buckets, k)));
    buckets_short_get_keys_rec(nwrp, buckets_remove_key_fp(buckets, k));
    assert buckets_get_keys_rec_fp(nwrp, keep_short_fp(buckets_remove_key_fp(buckets, k))) ==
           buckets_get_keys_rec_fp(nwrp, buckets_remove_key_fp(buckets, k));
    assert buckets_get_keys_rec_fp(nwrp, buckets) ==
           buckets_get_keys_rec_fp(nwrp, buckets_remove_key_fp(buckets, k));

    assert buckets_get_keys_fp(buckets_remove_key_fp(buckets, k)) ==
           buckets_get_keys_rec_fp(filter((not_this_key_pair_fp)(k),
                                          get_wraparound(nil, buckets)),
                                   buckets);
  }
}//took 60m + 40m so far
//TODO 300m

lemma void buckets_ok_chn_bound_rec<kt>(list<pair<kt, nat> > acc,
                                        list<bucket<kt> > buckets,
                                        int i,
                                        int bound)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         0 <= i &*& i < length(buckets) &*&
         0 < bound;
ensures length(buckets_get_chns_rec_fp(acc, buckets)) == length(buckets) &*&
        0 <= nth(i, buckets_get_chns_rec_fp(acc, buckets)) &*&
        nth(i, buckets_get_chns_rec_fp(acc, buckets)) <= bound - 1;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_keys_chns_same_len_rec(acc, buckets);
      list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
      if (i == 0) {
        assert nth(i, buckets_get_chns_rec_fp(acc, buckets)) ==
               length(advance_acc(acc_atb));
        assert 0 <= length(advance_acc(acc_atb));
        advance_acc_lower_limit(acc_atb, bound);
        list<nat> tails = map(snd, advance_acc(acc_atb));
        map_preserves_length(snd, advance_acc(acc_atb));
        assert length(advance_acc(acc_atb)) == length(tails);
        assert true == forall(advance_acc(acc_atb), (sup)((nat_lt)(bound - 1), snd));
        advance_acc_still_distinct(acc_atb);
        assert true == distinct(tails);
        forall_sup_map(advance_acc(acc_atb), (nat_lt)(bound - 1), snd);
        nat_lt_distinct_few(tails, bound - 1);
        assert length(advance_acc(acc_atb)) <= bound - 1;
      } else {
        buckets_ok_chn_bound_rec(advance_acc(acc_atb), t, i - 1, bound);
      }
  }
}

lemma void buckets_ok_chn_bound<kt>(list<bucket<kt> > buckets,
                                    int i)
requires true == buckets_ok(buckets) &*& 0 <= i &*& i < length(buckets);
ensures length(buckets_get_chns_fp(buckets)) == length(buckets) &*&
        0 <= nth(i, buckets_get_chns_fp(buckets)) &*&
        nth(i, buckets_get_chns_fp(buckets)) <= length(buckets);
{
  buckets_ok_chn_bound_rec(get_wraparound(nil, buckets), buckets,
                           i, length(buckets));
}//took 40m

lemma void gt_zero_neq_zero(int x)
requires 0 < x;
ensures 0 != x;
{
}

lemma void after_part_chn_rec_no_effect(list<int> chns,
                                        int start, int len,
                                        int i)
requires 0 <= start &*& 0 <= len &*& start + len <= i &*& i < length(chns);
ensures nth(i, chns) == nth(i, add_partial_chain_rec_fp(chns, start, len));
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        if (len != 0) {
          assert 0 < i;
          gt_zero_neq_zero(i);
          assert 0 != i;
          after_part_chn_rec_no_effect(t, 0, len - 1, i - 1);
        }
      } else {
        assert 0 < i;
        after_part_chn_rec_no_effect(t, start - 1, len, i - 1);
      }
  }
}

lemma void before_part_chn_rec_no_effect(list<int> chns,
                                         int start, int len,
                                         int i)
requires 0 <= start &*& 0 <= len &*& 0 <= i &*& i < start;
ensures nth(i, chns) ==
        nth(i, add_partial_chain_rec_fp(chns, start, len));
{
  switch(chns) {
    case nil:
    case cons(h,t):
      assert start != 0;
      if (i != 0) {
        before_part_chn_rec_no_effect(t, start - 1, len, i - 1);
      }
  }
}

lemma void outside_part_chn_no_effect(list<int> chns, int start, int fin,
                                      int capacity)
requires capacity == length(chns) &*& 0 <= fin &*& fin < capacity &*&
         0 <= start &*& start < capacity;
ensures nth(fin, chns) ==
        nth(fin, add_partial_chain_fp(start, (fin < start) ?
                                      capacity + fin - start :
                                      fin - start,
                                      chns));
{
  if (fin < start) {
    if (0 < fin) {
      before_part_chn_rec_no_effect(chns, start, capacity + fin - start, fin);
      add_part_chn_rec_same_len(start, capacity + fin - start, chns);
      after_part_chn_rec_no_effect
      (add_partial_chain_rec_fp(chns, start, capacity + fin - start),
       0, fin, fin);
    } else {
      assert fin == 0;
      before_part_chn_rec_no_effect(chns, start, capacity + fin - start, fin);
    }
  } else {
    after_part_chn_rec_no_effect(chns, start, fin - start, fin);
  }
}//took 35m

lemma void add_part_chn_rec_add_one(list<int> chns, list<int> orig_chns,
                                    int start, int len)
requires chns == add_partial_chain_rec_fp(orig_chns, start, len) &*&
         start + len + 1 <= length(orig_chns) &*&
         0 <= len &*&
         0 <= start;
ensures update(start + len, nth(start + len, chns) + 1, chns) ==
        add_partial_chain_rec_fp(orig_chns, start, len + 1);
{
  switch(orig_chns) {
    case nil:
    case cons(oh,ot):
      switch(chns) {
        case nil:
        case cons(rh,rt):
          if (start == 0) {
            if (len == 0) {
              add_part_chn_rec_zero_len(orig_chns, 0);
              add_part_chn_rec_zero_len(ot, 0);
            } else {
              add_part_chn_rec_add_one(rt, ot, 0, len - 1);
            }
          } else {
            add_part_chn_rec_add_one(rt, ot, start - 1, len);
          }
      }
  }
}

lemma void add_part_chain_rec_overflow(list<int> chns,
                                       int start,
                                       int len1,
                                       int len2)
requires length(chns) <= start + len1 &*&
         length(chns) <= start + len2;
ensures add_partial_chain_rec_fp(chns, start, len1) ==
        add_partial_chain_rec_fp(chns, start, len2);
{
  switch(chns) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        assert 0 < len1;
        assert 0 < len2;
        add_part_chain_rec_overflow(t, 0, len1 - 1, len2 - 1);
      } else {
        add_part_chain_rec_overflow(t, start - 1, len1, len2);
      }
  }
}

lemma void Xchain_add_one(list<int> chns, list<int> orig_chns, int start,
                          int len, int capacity)
requires chns == add_partial_chain_fp(start, len, orig_chns) &*&
         length(orig_chns) == capacity &*&
         0 <= start &*& start < capacity &*&
         0 <= len &*& len < capacity;
ensures update(loop_fp(start + len, capacity),
               nth(loop_fp(start + len, capacity), chns) + 1,
               chns) ==
        add_partial_chain_fp(start, len+1, orig_chns);
{
  if (length(orig_chns) < start + len) {
    add_part_chain_rec_overflow(orig_chns, start, len, len + 1);
    add_part_chn_rec_same_len(start, len, orig_chns);
    add_part_chn_rec_add_one(chns, add_partial_chain_rec_fp(orig_chns,
                                                            start, len),
                             0,
                             start + len - length(orig_chns));
    assert start + len - length(orig_chns) < capacity;
    loop_injection_n(start + len - length(orig_chns), capacity, 1);
    loop_bijection(start + len - length(orig_chns), capacity);
  } else {
    assert start + len <= capacity;
    if (start + len == capacity) {
      loop_injection_n(start + len - capacity, capacity, 1);
      loop_bijection(start + len - capacity, capacity);
      add_part_chain_rec_overflow(orig_chns, start, len, len + 1);
      add_part_chn_rec_zero_len
      (add_partial_chain_rec_fp(orig_chns, start, len+1), 0);
      add_part_chn_rec_same_len(start, len + 1, orig_chns);
      add_part_chn_rec_add_one(add_partial_chain_rec_fp
                               (orig_chns, start, len+1),
                               add_partial_chain_rec_fp
                               (orig_chns, start, len+1),
                               0, 0);
    } else {
      assert start + len < capacity;
      add_part_chn_rec_add_one(chns, orig_chns, start, len);
      loop_bijection(start + len, capacity);
    }
  }
}//took 75m

fixpoint list<bucket<kt> > empty_buckets_fp<kt>(nat len) {
  return repeat_n(len, bucket(nil));
}

lemma void empty_buckets_empty_wraparound<kt>(nat capacity)
requires true;
ensures get_wraparound(nil, empty_buckets_fp<kt>(capacity)) == nil;
{
  switch(capacity) {
    case zero:
    case succ(n):
      empty_buckets_empty_wraparound(n);
  }
}

lemma void empty_buckets_chns_zeros_rec<kt>(nat capacity)
requires true;
ensures repeat_n(capacity, 0) ==
        buckets_get_chns_rec_fp(nil, empty_buckets_fp<kt>(capacity));
{
  switch(capacity) {
    case zero:
    case succ(n):
      empty_buckets_chns_zeros_rec(n);
  }
}

lemma void empty_buckets_chns_zeros<kt>(nat capacity)
requires true;
ensures repeat_n(capacity, 0) ==
        buckets_get_chns_fp(empty_buckets_fp<kt>(capacity));
{
  empty_buckets_empty_wraparound(capacity);
  empty_buckets_chns_zeros_rec(capacity);
}

lemma void empty_buckets_ks_none_rec<kt>(nat capacity)
requires true;
ensures repeat_n<option<kt> >(capacity, none) ==
        buckets_get_keys_rec_fp(nil, empty_buckets_fp<kt>(capacity));
{
  switch(capacity) {
    case zero:
    case succ(n):
      empty_buckets_ks_none_rec(n);
  }
}

lemma void empty_buckets_ks_none<kt>(nat capacity)
requires capacity != zero;
ensures repeat_n<option<kt> >(capacity, none) ==
        buckets_get_keys_fp(empty_buckets_fp<kt>(capacity));
{
  empty_buckets_empty_wraparound(capacity);
  empty_buckets_ks_none_rec(capacity);
}

lemma void empty_buckets_ok_rec<kt>(nat capacity, int bound)
requires true;
ensures true == buckets_ok_rec(nil, empty_buckets_fp<kt>(capacity), bound);
{
  switch(capacity) {
    case zero:
    case succ(n):
      empty_buckets_ok_rec(n, bound);
  }
}

lemma void empty_buckets_length<kt>(nat len)
requires true;
ensures length(empty_buckets_fp<kt>(len)) == int_of_nat(len);
{
  repeat_n_length(len, bucket(nil));
}

lemma void empty_buckets_keys_distinct<kt>(nat len)
requires true;
ensures true == distinct(buckets_all_keys_fp(empty_buckets_fp<kt>(len)));
{
  switch(len) {
    case zero:
    case succ(n):
      empty_buckets_keys_distinct(n);
  }
}//took 1m

lemma void empty_buckets_ok<kt>(nat capacity)
requires capacity != zero;
ensures true == buckets_ok(empty_buckets_fp<kt>(capacity));
{
  empty_buckets_empty_wraparound(capacity);
  empty_buckets_length(capacity);
  empty_buckets_ok_rec(capacity, int_of_nat(capacity));
  empty_buckets_keys_distinct(capacity);
}

lemma void buckets_put_same_len<kt>(list<bucket<kt> > buckets,
                                    kt k, int start, int dist)
requires true;
ensures length(buckets_put_key_fp(buckets, k, start, dist)) ==
        length(buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (start != 0)
      buckets_put_same_len(t, k, start - 1, dist);
  }
}

lemma void advance_acc_still_eq<kt>(list<pair<kt, nat> > acc1,
                                    list<pair<kt, nat> > acc2)
requires true == set_eq(acc1, acc2);
ensures true == set_eq(advance_acc(acc1), advance_acc(acc2));
{
  advance_acc_subset(acc1, acc2);
  advance_acc_subset(acc2, acc1);
}

lemma void acc_at_this_bucket_still_eq<kt>(list<pair<kt, nat> > acc1,
                                           list<pair<kt, nat> > acc2,
                                           bucket<kt> b)
requires true == set_eq(acc1, acc2);
ensures true == set_eq(acc_at_this_bucket(acc1, b),
                       acc_at_this_bucket(acc2, b));
{
  acc_at_this_bucket_subset(acc1, acc2, b);
  acc_at_this_bucket_subset(acc2, acc1, b);
}

fixpoint list<bucket<kt> > keep_short_fp<kt>(list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil:
      return nil;
    case cons(bh,bt):
      return switch(bh) {
        case bucket(chains):
          return cons(bucket(filter((sup)((nat_lt)(length(buckets)),snd),
                                    chains)),
                      keep_short_fp(bt));
      };
  }
}

fixpoint list<bucket<kt> > keep_long_fp<kt>(list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil:
      return nil;
    case cons(bh,bt):
      return switch(bh) {
        case bucket(chains):
          return cons(bucket(filter((sup)((nat_ge)(length(buckets)), snd),
                                    chains)),
                      keep_long_fp(bt));
      };
  }
}

fixpoint bool buckets_short_fp<kt>(list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil: return true;
    case cons(bh,bt):
      return switch(bh) {
        case bucket(chains):
          return forall(chains, (sup)((nat_lt)(length(buckets)), snd)) &&
          buckets_short_fp(bt);
      };
  }
}

fixpoint bool buckets_long_fp<kt>(list<bucket<kt> > buckets) {
  switch(buckets) {
    case nil: return true;
    case cons(bh,bt):
      return switch(bh) {
        case bucket(chains):
          return forall(chains, (sup)((nat_ge)(length(buckets)), snd)) &&
          buckets_long_fp(bt);
      };
  }
}

fixpoint list<bucket<kt> > join_buckets_fp<kt>(list<bucket<kt> > bkts1,
                                               list<bucket<kt> > bkts2) {
  switch(bkts1) {
    case nil:
      return nil; //bkts2 should be nil
    case cons(h1,t1):
      return switch(bkts2) {
        case nil:
          return nil; //must never happen
        case cons(h2,t2):
          return switch(h1) {
            case bucket(chains1):
              return switch(h2) {
                case bucket(chains2):
                  return cons(bucket(append(chains1, chains2)),
                              join_buckets_fp(t1,t2));
              };
          };
      };
  }
}

fixpoint bool buckets_content_eq_fp<kt>(list<bucket<kt> > bkts1,
                                        list<bucket<kt> > bkts2) {
  switch(bkts1) {
    case nil:
      return bkts2 == nil;
    case cons(h1,t1):
      return switch(bkts2) {
        case nil: return false;
        case cons(h2,t2):
          return switch(h1) {
            case bucket(chains1):
              return switch(h2) {
                case bucket(chains2):
                  return set_eq(chains1, chains2) &&
                  buckets_content_eq_fp(t1, t2);
              };
          };
      };
  }
}

lemma void buckets_put_key_keep_short_swap<kt>(list<bucket<kt> > buckets,
                                               kt k, int start, int dist)
requires 0 <= dist &*& start + dist < length(buckets);
ensures keep_short_fp(buckets_put_key_fp(buckets, k, start, dist)) ==
        buckets_put_key_fp(keep_short_fp(buckets), k, start, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          buckets_put_same_len(buckets, k, start, dist);
          if (start == 0) {
          } else {
            buckets_put_key_keep_short_swap(t, k, start - 1, dist);
          }
      }
  }
}//took 9m

lemma void buckets_put_key_keep_long_no_effect<kt>(list<bucket<kt> > buckets,
                                                   kt k, int start, int dist)
requires 0 <= start &*& start < length(buckets) &*&
         0 <= dist &*&
         start + dist < length(buckets);
ensures keep_long_fp(buckets) ==
        keep_long_fp(buckets_put_key_fp(buckets, k, start, dist));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
            assert dist < length(buckets);
            assert int_of_nat(nat_of_int(dist)) == dist;
            assert filter((sup)((nat_ge)(length(buckets)), snd),
                          cons(pair(k, nat_of_int(dist)), chains)) ==
                   filter((sup)((nat_ge)(length(buckets)), snd), chains);
          } else {
            buckets_put_same_len(buckets, k, start, dist);
            buckets_put_key_keep_long_no_effect(t, k, start - 1, dist);
          }
      }
  }
}//took 30m

lemma void advance_acc_still_disjoint<kt>(list<pair<kt, nat> > acc1,
                                          list<pair<kt, nat> > acc2)
requires true == disjoint(map(snd, acc1), map(snd, acc2));
ensures true == disjoint(map(snd, advance_acc(acc1)),
                         map(snd, advance_acc(acc2)));
{
  switch(acc2) {
    case nil:
    case cons(h,t):
      advance_acc_still_disjoint(acc1, t);
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              advance_acc_dec_nonmem(n, acc1);
          }
      }
  }
}//took 7m

lemma void buckets_split_ok_orig_ok_rec<kt>(list<pair<kt, nat> > sacc,
                                            list<pair<kt, nat> > lacc,
                                            list<pair<kt, nat> > acc,
                                            list<bucket<kt> > buckets,
                                            int bound)
requires true == buckets_ok_rec(sacc, keep_short_fp(buckets), bound) &*&
         true == buckets_ok_rec(lacc, keep_long_fp(buckets), bound) &*&
         true == forall(sacc, (sup)((nat_lt)(length(buckets)), snd)) &*&
         true == forall(lacc, (sup)((nat_ge)(length(buckets)), snd)) &*&
         true == disjoint(map(snd, sacc), map(snd, lacc)) &*&
         true == multiset_eq(acc, append(sacc, lacc));
ensures true == buckets_ok_rec(acc, buckets, bound);
{
  switch(buckets) {
    case nil:
      map_append(snd, sacc, lacc);
      distinct_and_disjoint_append(map(snd, sacc), map(snd, lacc));
      multiset_eq_map(snd, acc, append(sacc, lacc));
      multiset_eq_distinct(map(snd, acc),
                           map(snd, append(sacc, lacc)));
      forall_append(sacc, lacc, (sup)((nat_lt)(bound - 1), snd));
      multiset_eq_forall(acc, append(sacc, lacc), (sup)((nat_lt)(bound - 1), snd));
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > lchains =
          filter((sup)((nat_ge)(length(buckets)), snd), chains);
          list<pair<kt, nat> > schains =
          filter((sup)((nat_lt)(length(buckets)), snd), chains);
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > satb = append(sacc, schains);
          list<pair<kt, nat> > latb = append(lacc, lchains);

          lower_and_upper_limit_complement(chains, length(buckets));
          multiset_eq_comm(append(lchains, schains), chains);
          map_append(snd, acc, chains);
          map_append(snd, sacc, schains);
          map_append(snd, lacc, lchains);
          assert true == multiset_eq(acc, append(sacc, lacc));
          assert true == multiset_eq(chains, append(lchains, schains));
          assert atb == append(acc, chains);
          multiset_eq_refl(atb);
          multiset_eq_append(acc, append(sacc, lacc),
                             chains, append(lchains, schains));
          multiset_eq_trans(atb, append(acc, chains),
                            append(append(sacc, lacc), append(lchains, schains)));


          assert true == multiset_eq(atb, append(append(sacc, lacc), append(lchains, schains)));
          multiset_eq_reshuffle_appends(atb, sacc, lacc, lchains, schains);
          assert true == multiset_eq(atb, append(append(sacc, schains), append(lacc, lchains)));
          assert true == multiset_eq(atb, append(satb, latb));
          assert true == distinct(map(snd, satb));
          assert true == distinct(map(snd, latb));
          assert true == disjoint(map(snd, sacc), map(snd, lacc));
          disjoint_comm(map(snd, lchains),
                        map(snd, schains));
          assert true == disjoint(map(snd, schains), map(snd, lchains));
          assert true == forall(sacc,
                                (sup)((nat_lt)(length(buckets)), snd));
          forall_sup_map(sacc, (nat_lt)(length(buckets)), snd);
          filter_forall((sup)((nat_lt)(length(buckets)), snd), chains);
          forall_sup_map(schains, (nat_lt)(length(buckets)), snd);
          assert true == forall(map(snd, sacc),
                                (nat_lt)(length(buckets)));
          filter_forall((sup)((nat_ge)(length(buckets)), snd), chains);
          assert true == forall(lchains, (sup)((nat_ge)(length(buckets)), snd));
          forall_sup_map(lacc, (nat_ge)(length(buckets)), snd);
          forall_sup_map(lchains, (nat_ge)(length(buckets)), snd);
          assert true == forall(map(snd, lchains),
                                (nat_ge)(length(buckets)));
          separated_by_bnd_disjoint(map(snd, sacc), map(snd, lchains),
                                    length(buckets));
          separated_by_bnd_disjoint(map(snd, schains), map(snd, lacc),
                                    length(buckets));
          disjoint_comm(map(snd, schains), map(snd, lacc));
          assert true == disjoint(map(snd, sacc),
                                  map(snd, lchains));
          disjoint_append(map(snd, sacc), map(snd, schains),
                          map(snd, lacc), map(snd, lchains));
          assert true == disjoint(map(snd, satb), map(snd, latb));
          distinct_and_disjoint_append(map(snd, satb),
                                       map(snd, latb));
          map_append(snd, satb, latb);
          assert true == distinct(map(snd, append(satb, latb)));
          multiset_eq_map(snd, atb, append(satb, latb));
          multiset_eq_distinct(map(snd, atb),
                               map(snd, append(satb, latb)));
          assert true == distinct(map(snd, atb));
          advance_acc_still_distinct(atb);
          assert true == forall(satb, (sup)((nat_lt)(bound), snd));
          assert true == forall(latb, (sup)((nat_lt)(bound), snd));
          forall_append(satb, latb, (sup)((nat_lt)(bound), snd));
          assert true == forall(append(satb, latb), (sup)((nat_lt)(bound), snd));
          multiset_eq_forall(atb, append(satb, latb), (sup)((nat_lt)(bound), snd));
          assert true == forall(atb, (sup)((nat_lt)(bound), snd));
          assert true == multiset_eq(atb, append(satb, latb));
          advance_acc_multiset_eq(atb, append(satb, latb));
          advance_acc_append_commute(satb, latb);
          advance_acc_still_disjoint(satb, latb);
          forall_append(sacc, schains, (sup)((nat_lt)(length(buckets)), snd));
          forall_append(lacc, lchains, (sup)((nat_ge)(length(buckets)), snd));
          advance_acc_lower_limit(satb, length(buckets));
          advance_acc_lower_llimit(latb, length(buckets));
          buckets_split_ok_orig_ok_rec(advance_acc(satb),
                                       advance_acc(latb),
                                       advance_acc(atb),
                                       t,
                                       bound);
      }
  }
}

lemma void buckets_split_ok_orig_ok<kt>(list<pair<kt, nat> > acc,
                                        list<bucket<kt> > buckets,
                                        int bound)
requires true == buckets_ok_rec(acc, keep_short_fp(buckets), bound) &*&
         true == buckets_ok_rec(acc, keep_long_fp(buckets), bound);
ensures true == buckets_ok_rec(acc, buckets, bound);
{
  list<pair<kt, nat> > sacc = filter((sup)((nat_lt)(length(buckets)), snd), acc);
  list<pair<kt, nat> > lacc = filter((sup)((nat_ge)(length(buckets)), snd), acc);
  filter_msubset((sup)((nat_lt)(length(buckets)), snd), acc);
  filter_msubset((sup)((nat_ge)(length(buckets)), snd), acc);
  msubset_subset(sacc, acc);
  msubset_subset(lacc, acc);
  msubset_map(snd, sacc, acc);
  msubset_map(snd, lacc, acc);
  buckets_ok_rec_acc_tails_distinct(acc, keep_short_fp(buckets), bound);
  msubset_distinct(map(snd, sacc), map(snd, acc));
  msubset_distinct(map(snd, lacc), map(snd, acc));
  lower_and_upper_limit_complement(acc, length(buckets));
  acc_subset_buckets_still_ok_rec(sacc, acc, keep_short_fp(buckets), bound);
  acc_subset_buckets_still_ok_rec(lacc, acc, keep_long_fp(buckets), bound);
  disjoint_comm(map(snd, sacc), map(snd, lacc));
  multiset_eq_append_comm(sacc, lacc);
  multiset_eq_trans(append(sacc, lacc), append(lacc, sacc), acc);
  multiset_eq_comm(append(sacc, lacc), acc);
  filter_forall((sup)((nat_ge)(length(buckets)), snd), acc);
  filter_forall((sup)((nat_lt)(length(buckets)), snd), acc);
  buckets_split_ok_orig_ok_rec(sacc, lacc, acc,
                               buckets, bound);
}//took 40m

lemma void accs_eq_tails_distinct<kt>(list<pair<kt, nat> > acc1,
                                      list<pair<kt, nat> > acc2)
requires true == distinct(map(snd, acc1)) &*&
         true == set_eq(acc1, acc2) &*&
         length(acc1) == length(acc2);
ensures true == distinct(map(snd, acc2));
{
  content_eq_map(acc1, acc2, snd);
  map_preserves_length(snd, acc1);
  map_preserves_length(snd, acc2);
  set_eq_same_len_distinct_both(map(snd, acc1),
                                map(snd, acc2));
}

lemma void acc_eq_buckets_ok_rec<kt>(list<pair<kt, nat> > acc1,
                                     list<pair<kt, nat> > acc2,
                                     list<bucket<kt> > buckets,
                                     int bound)
requires true == set_eq(acc1, acc2) &*&
         true == buckets_ok_rec(acc1, buckets, bound) &*&
         true == distinct(map(snd, acc2));
ensures true == buckets_ok_rec(acc2, buckets, bound);
{
  switch(buckets) {
    case nil:
      set_eq_forall_both(acc1, acc2, (sup)((nat_lt)(bound - 1), snd));
    case cons(h,t):
      list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
      list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
      switch(h) {
        case bucket(chains):
          map_append(snd, acc1, chains);
          distinct_unappend(map(snd, acc1), map(snd, chains));
      }
      distinct_unmap(acc1, snd);
      distinct_unmap(acc2, snd);
      set_eq_distinct_same_len(acc1, acc2);
      assert length(atb1) == length(atb2);
      acc_at_this_bucket_still_eq(acc1, acc2, h);
      accs_eq_tails_distinct(atb1, atb2);
      set_eq_forall_both(atb1, atb2, (sup)((nat_lt)(bound), snd));
      advance_acc_still_eq(atb1, atb2);
      advance_acc_still_distinct(atb2);
      acc_eq_buckets_ok_rec(advance_acc(atb1), advance_acc(atb2), t, bound);
  }
}//took 60m

lemma void acc_at_bucket_put_is_cons<kt>(list<pair<kt, nat> > acc,
                                         bucket<kt> bucket,
                                         kt k, int dist)
requires true;
ensures true == set_eq(acc_at_this_bucket(acc,
                                          bucket_put_key_fp(bucket,
                                                            k,
                                                            dist)),
                       cons(pair(k, nat_of_int(dist)),
                            acc_at_this_bucket(acc, bucket))) &*&
        length(acc_at_this_bucket(acc, bucket_put_key_fp(bucket, k, dist))) ==
        length(acc_at_this_bucket(acc, bucket)) + 1;
{
  switch(bucket) {
    case bucket(chains):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, bucket);
      list<pair<kt, nat> > atb_add =
      acc_at_this_bucket(acc, bucket_put_key_fp(bucket, k, dist));
      cons_in_the_middle_multiset_eq(acc, chains, pair(k, nat_of_int(dist)));
      multiset_eq_set_eq(atb_add, cons(pair(k, nat_of_int(dist)), atb));
      multiset_eq_same_len(atb_add, cons(pair(k, nat_of_int(dist)), atb));
  }
}//took 5m (again, kind of a duplicate of another lemma)

lemma void acc_eq_cons_get_chns_like_add_part_chn<kt>(list<pair<kt, nat> > acc,
                                                      list<pair<kt, nat> > orig,
                                                      list<bucket<kt> > buckets,
                                                      kt k, int dist)
requires 0 <= dist &*&
         true == multiset_eq(acc, cons(pair(k, nat_of_int(dist)), orig));
ensures buckets_get_chns_rec_fp(acc, buckets) ==
        add_partial_chain_rec_fp(buckets_get_chns_rec_fp(orig, buckets),
                                 0, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      list<pair<kt, nat> > orig_atb = acc_at_this_bucket(orig, h);
      switch(h) {
        case bucket(chains):
          multiset_eq_append_both(acc, cons(pair(k, nat_of_int(dist)), orig),
                                  chains);
          assert true == multiset_eq(atb, cons(pair(k, nat_of_int(dist)),
                                               orig_atb));
          advance_acc_multiset_eq(atb, cons(pair(k, nat_of_int(dist)),
                                            orig_atb));
          multiset_eq_same_len(advance_acc(atb),
                               advance_acc(cons(pair(k, nat_of_int(dist)),
                                                orig_atb)));
          if (dist == 0) {
            assert advance_acc(cons(pair(k, nat_of_int(dist)), orig_atb)) ==
                   advance_acc(orig_atb);
            assert true == multiset_eq(advance_acc(atb), advance_acc(orig_atb));
            acc_eq_get_chns_eq(advance_acc(atb), advance_acc(orig_atb), t);
          } else {
            nat prev_d = nat_of_int(dist - 1);
            assert nat_of_int(dist) == succ(prev_d);
            acc_eq_cons_get_chns_like_add_part_chn(advance_acc(atb),
                                                   advance_acc(orig_atb),
                                                   t, k, dist - 1);
          }
      }
  }
}

lemma void acc_additional_zero_chain_same_chns<kt>(list<pair<kt, nat> > acc1,
                                                   list<pair<kt, nat> > acc2,
                                                   list<bucket<kt> > buckets,
                                                   kt k)
requires true == multiset_eq(acc1, cons(pair(k, zero), acc2)) &*&
         buckets != nil;
ensures buckets_get_chns_rec_fp(acc1, buckets) ==
        buckets_get_chns_rec_fp(acc2, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
  }
  assert 0 < length(buckets);
  acc_eq_cons_get_chns_like_add_part_chn(acc1, acc2, buckets, k, 0);
  add_part_chn_zero_len(buckets_get_chns_rec_fp(acc2, buckets), 0);
}

lemma void long_chain_in_acc_to_wraparound<kt>(list<pair<kt, nat> > acc,
                                               list<pair<kt, nat> > orig,
                                               list<bucket<kt> > buckets,
                                               kt k, int dist)
requires true == multiset_eq(acc, cons(pair(k, nat_of_int(dist)), orig)) &*&
         length(buckets) <= dist;
ensures true == multiset_eq(get_wraparound(acc, buckets),
                            cons(pair(k, nat_of_int(dist - length(buckets))),
                                 get_wraparound(orig, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > orig_atb = acc_at_this_bucket(orig, h);
          multiset_eq_append_both(acc, cons(pair(k, nat_of_int(dist)), orig),
                                  chains);
          assert 0 < dist;
          int prev_dist = dist - 1;
          assert nat_of_int(dist) == succ(nat_of_int(prev_dist));
          advance_acc_multiset_eq(atb, cons(pair(k, nat_of_int(dist)),
                                            orig_atb));
          long_chain_in_acc_to_wraparound(advance_acc(atb), advance_acc(orig_atb),
                                          t, k, dist - 1);
      }
  }
}

lemma void buckets_put_wraparound_eq_cons<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets,
                                              kt k, int start, int dist)
requires length(buckets) <= start + dist &*&
         0 <= start &*& start < length(buckets);
ensures true == multiset_eq(get_wraparound(acc, buckets_put_key_fp
                                           (buckets, k, start, dist)),
                            cons(pair(k, nat_of_int(dist + start -
                                                    length(buckets))),
                                 get_wraparound(acc, buckets)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (start == 0) {
            list<pair<kt, nat> > new_atb =
            acc_at_this_bucket(acc, bucket_put_key_fp(h, k, dist));
            cons_in_the_middle_multiset_eq(acc, chains,
                                           pair(k, nat_of_int(dist)));
            assert true == multiset_eq
                   (new_atb, cons(pair(k, nat_of_int(dist)), atb));
            advance_acc_multiset_eq(new_atb, cons(pair(k, nat_of_int(dist)),
                                                  atb));
            assert 0 < dist;
            int prev_dist = dist - 1;
            assert nat_of_int(dist) == succ(nat_of_int(prev_dist));
            long_chain_in_acc_to_wraparound
            (advance_acc(new_atb), advance_acc(atb), t, k, prev_dist);
          } else {
            buckets_put_wraparound_eq_cons
            (advance_acc(atb), t, k, start - 1, dist);
          }
      }
  }
}

lemma void buckets_put_wraparound_is_cons<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets,
                                              kt k, int start, int dist)
requires length(buckets) <= dist + start &*&
         0 <= start &*& start < length(buckets);
ensures true == set_eq
        (get_wraparound(acc,
                        buckets_put_key_fp(buckets, k,
                                           start, dist)),
         cons(pair(k, nat_of_int(dist + start - length(buckets))),
              get_wraparound(acc, buckets))) &*&
        length(get_wraparound(acc, buckets_put_key_fp(buckets, k,
                                                      start, dist))) ==
        length(get_wraparound(acc, buckets)) + 1;
{
  buckets_put_wraparound_eq_cons(acc, buckets, k, start, dist);
  list<pair<kt, nat> > wrp1 = get_wraparound(acc,
                                             buckets_put_key_fp(buckets, k,
                                                                start, dist));
  list<pair<kt, nat> > wrp2 =
  cons(pair(k, nat_of_int(dist + start - length(buckets))),
       get_wraparound(acc, buckets));

  multiset_eq_set_eq(wrp1, wrp2);
  multiset_eq_same_len(wrp1, wrp2);
}//took 10m (it is kind of a duplicate of another, more strong lemma)


lemma void get_current_key_none_subset_none<kt>(list<pair<kt, nat> > acc1,
                                                list<pair<kt, nat> > acc2)
requires get_current_key_fp(acc1) == none &*&
         true == subset(acc2, acc1);
ensures get_current_key_fp(acc2) == none;
{
  switch(acc2) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              subset_mem_trans(acc2, acc1, h);
              assert true == mem(h, acc1);
              mem_map(h, acc1, snd);
              assert true == mem(zero, map(snd, acc1));
              nozero_no_current_key(acc1);
              assert false;
            case succ(n):
              get_current_key_none_subset_none(acc1, t);
          }
      }
  }
}//took 8m


lemma void acc_subset_also_none<kt>(list<pair<kt, nat> > acc1,
                                    list<pair<kt, nat> > acc2,
                                    list<bucket<kt> > buckets,
                                    int x)
requires 0 <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc1, buckets)) == none &*&
         true == subset(acc2, acc1);
ensures nth(x, buckets_get_keys_rec_fp(acc2, buckets)) == none;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
          list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
          append_both_subset(acc2, chains, acc1);
          if (x == 0) {
            get_current_key_none_subset_none(atb1, atb2);
          } else {
            advance_acc_subset(atb2, atb1);
            acc_subset_also_none(advance_acc(atb1), advance_acc(atb2),
                                 t, x - 1);
          }
      }
  }
}//took 5m


lemma void no_key_especially_in_short_and_long<kt>(list<pair<kt, nat> > acc,
                                                   list<bucket<kt> > buckets,
                                                   int x)
requires 0 <= x &*& x < length(buckets) &*&
         nth(x, buckets_get_keys_rec_fp(acc, buckets)) == none;
ensures nth(x, buckets_get_keys_rec_fp(acc, keep_long_fp(buckets))) == none &*&
        nth(x, buckets_get_keys_rec_fp(acc, keep_short_fp(buckets))) == none;
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > latb =
          append(acc, filter((sup)((nat_ge)(length(buckets)), snd), chains));
          list<pair<kt, nat> > satb =
          append(acc, filter((sup)((nat_lt)(length(buckets)), snd), chains));
          filter_subset((sup)((nat_ge)(length(buckets)), snd), chains);
          filter_subset((sup)((nat_lt)(length(buckets)), snd), chains);
          append_both_subset(filter((sup)((nat_ge)(length(buckets)), snd), chains),
                             acc,
                             chains);
          append_both_subset(filter((sup)((nat_lt)(length(buckets)), snd), chains),
                             acc,
                             chains);
          assert true == subset(latb, atb);
          assert true == subset(satb, atb);
          if (x == 0) {
            get_current_key_none_subset_none(atb, latb);
            get_current_key_none_subset_none(atb, satb);
          } else {
            advance_acc_subset(latb, atb);
            advance_acc_subset(satb, atb);
            no_key_especially_in_short_and_long(advance_acc(atb), t, x - 1);
            keep_long_same_len(t);
            keep_short_same_len(t);
            acc_subset_also_none(advance_acc(atb), advance_acc(latb),
                                 keep_long_fp(t), x - 1);
            acc_subset_also_none(advance_acc(atb), advance_acc(satb),
                                 keep_short_fp(t), x - 1);
          }
      }
  }
}//took 30m

lemma void advance_acc_keeps_tail_mem<kt>(list<pair<kt, nat> > acc,
                                          nat dist)
requires true;
ensures mem(dist, map(snd, advance_acc(acc))) ==
        mem(succ(dist), map(snd, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,d):
          switch(d) {
            case zero:
            case succ(n):
          }
      }
      advance_acc_keeps_tail_mem(t, dist);
  }
  
}//took 5m

lemma void get_key_none_no_chain<kt>(list<pair<kt, nat> > acc,
                                     list<bucket<kt> > buckets,
                                     int dist)
requires 0 <= dist &*& dist < length(buckets) &*&
         nth(dist, buckets_get_keys_rec_fp(acc, buckets)) == none;
ensures false == mem(nat_of_int(dist), map(snd, acc));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      if (dist == 0) {
        if (mem(zero, map(snd, atb))) {
          nozero_no_current_key(atb);
        }
      } else {
        get_key_none_no_chain(advance_acc(atb), t, dist - 1);
        assert succ(nat_of_int(dist - 1)) == nat_of_int(dist);
        advance_acc_keeps_tail_mem(atb, nat_of_int(dist - 1));
        assert false == mem(nat_of_int(dist), map(snd, atb));
      }
      switch(h) {
        case bucket(chains):
          map_append(snd, acc, chains);
          assert false == mem(nat_of_int(dist), map(snd, acc));
      }
  }
}//took 15m

lemma void cons_acc_atb_swap<kt>(list<pair<kt, nat> > acc,
                                 bucket<kt> b,
                                 pair<kt, nat> x)
requires true;
ensures acc_at_this_bucket(cons(x, acc), b) ==
        cons(x, acc_at_this_bucket(acc, b));
{
  switch(b) {
    case bucket(chains):
  }
}//took 2m

        lemma void
        acc_add_chain_buckets_ok_rec<kt>(list<pair<kt, nat> > acc,
                                         list<bucket<kt> > buckets,
                                         kt k, int dist,
                                         int bound)
requires 0 <= dist &*& dist < length(buckets) &*&
         length(buckets) <= bound &*&
         nth(dist, buckets_get_keys_rec_fp(acc, buckets)) == none &*&
         true == buckets_ok_rec(acc, buckets, bound);
ensures true == buckets_ok_rec(cons(pair(k, nat_of_int(dist)), acc),
                               buckets, bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
      list<pair<kt, nat> > new_acc_atb =
      acc_at_this_bucket(cons(pair(k, nat_of_int(dist)), acc), h);
      cons_acc_atb_swap(acc, h, pair(k, nat_of_int(dist)));
      assert new_acc_atb == cons(pair(k, nat_of_int(dist)), acc_atb);
      assert true == forall(new_acc_atb, (sup)((nat_lt)(bound), snd));
      if (dist == 0) {
        assert advance_acc(acc_atb) == advance_acc(new_acc_atb);
        assert get_current_key_fp(acc_atb) == none;
        if (mem(zero, map(snd, acc_atb)))
        nozero_no_current_key(acc_atb);

      } else {
        get_key_none_no_chain(advance_acc(acc_atb), t, dist - 1);
        advance_acc_keeps_tail_mem(acc_atb, nat_of_int(dist - 1));
        assert true == distinct(map(snd, new_acc_atb));
        acc_add_chain_buckets_ok_rec(advance_acc(acc_atb),
                                     t, k, dist - 1, bound);
        assert advance_acc(new_acc_atb) ==
               cons(pair(k, nat_of_int(dist - 1)), advance_acc(acc_atb));
        assert true == buckets_ok_rec(advance_acc(new_acc_atb), t, bound);
      }
  }
}

lemma void short_buckets_put_still_ok_rec<kt>(list<pair<kt, nat> > acc,
                                              list<bucket<kt> > buckets,
                                              kt k, int start, int dist,
                                              int bound)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*& dist < bound &*&
         start + dist < length(buckets) &*&
         length(buckets) <= bound &*&
         true == buckets_short_fp(buckets) &*&
         nth(start + dist, buckets_get_keys_rec_fp(acc, buckets)) == none;
ensures true == buckets_ok_rec(acc, buckets_put_key_fp(buckets, k, start,
                                                       dist),
                               bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
        list<pair<kt, nat> > new_acc_atb =
        acc_at_this_bucket(acc, bucket_put_key_fp(h, k, dist));

        acc_at_bucket_put_is_cons(acc, h, k, dist);
        assert true == set_eq(cons(pair(k, nat_of_int(dist)),
                                   acc_atb),
                              new_acc_atb);
        assert true == forall(cons(pair(k, nat_of_int(dist)), acc_atb),
                              (sup)((nat_lt)(bound), snd));
        set_eq_forall_both(cons(pair(k, nat_of_int(dist)), acc_atb),
                           new_acc_atb, (sup)((nat_lt)(bound), snd));
        assert true == forall(new_acc_atb, (sup)((nat_lt)(bound), snd));
        assert true == distinct(map(snd, acc_atb));
        if (dist == 0) {
          assert get_current_key_fp(acc_atb) == none;
          if (mem(zero, map(snd, acc_atb)))
          nozero_no_current_key(acc_atb);
          assert false == mem(zero, map(snd, acc_atb));
          assert true == distinct(map(snd, acc_atb));
          assert true == distinct(map(snd, cons(pair(k, zero), acc_atb)));

          accs_eq_tails_distinct(cons(pair(k, zero), acc_atb),
                                 new_acc_atb);
          assert advance_acc(cons(pair(k, zero), acc_atb)) ==
                 advance_acc(acc_atb);
          advance_acc_still_eq(cons(pair(k, zero), acc_atb),
                               new_acc_atb);
          advance_acc_still_distinct(new_acc_atb);
          acc_eq_buckets_ok_rec(advance_acc(acc_atb),
                                advance_acc(new_acc_atb),
                                t, bound);
        } else {
          get_key_none_no_chain(advance_acc(acc_atb), t, dist - 1);
          assert false == mem(nat_of_int(dist - 1), map(snd, advance_acc(acc_atb)));
          advance_acc_keeps_tail_mem(acc_atb, nat_of_int(dist - 1));
          assert false == mem(nat_of_int(dist), map(snd, acc_atb));
          assert true == distinct(map(snd, cons(pair(k, nat_of_int(dist)), acc_atb)));
          assert length(cons(pair(k, nat_of_int(dist)), acc_atb)) ==
                 length(new_acc_atb);

          accs_eq_tails_distinct(cons(pair(k, nat_of_int(dist)), acc_atb),
                                 new_acc_atb);
          assert true == distinct(map(snd, new_acc_atb));
          assert advance_acc(cons(pair(k, nat_of_int(dist)), acc_atb)) ==
                 cons(pair(k, nat_of_int(dist - 1)), advance_acc(acc_atb));
          acc_add_chain_buckets_ok_rec(advance_acc(acc_atb),
                                       t, k, dist - 1, bound);
          assert true == buckets_ok_rec
                 (advance_acc(cons(pair(k, nat_of_int(dist)),
                                   acc_atb)),
                  t, bound);
          advance_acc_still_eq(cons(pair(k, nat_of_int(dist)),
                                    acc_atb),
                               new_acc_atb);
          advance_acc_still_distinct(new_acc_atb);
          acc_eq_buckets_ok_rec(advance_acc(cons(pair(k, nat_of_int(dist)),
                                                 acc_atb)),
                                advance_acc(new_acc_atb),
                                t, bound);
        }
      } else {
        switch(h) { case bucket(chains): }
        short_buckets_put_still_ok_rec(advance_acc(acc_at_this_bucket(acc, h)),
                                       t, k, start - 1, dist, bound);
      }
  }
}


lemma void buckets_put_short_chain_same_wraparound<kt>(list<pair<kt, nat> > acc,
                                                       list<bucket<kt> > buckets,
                                                       kt k,
                                                       int start,
                                                       int dist,
                                                       int capacity)
requires 0 <= start &*& start < length(buckets) &*&
         start + dist < length(buckets) &*&
         0 <= dist;
ensures get_wraparound(acc, buckets_put_key_fp(buckets, k, start,
                                               dist)) ==
        get_wraparound(acc, buckets);
{

  keep_long_same_wraparound(acc, buckets);
  keep_long_same_wraparound(acc, buckets_put_key_fp(buckets, k, start, dist));
  buckets_put_key_keep_long_no_effect(buckets, k, start, dist);
}

lemma void buckets_put_key_keep_short_no_effect<kt>(list<bucket<kt> >buckets,
                                                    kt k, int start, int dist)
requires length(buckets) <= start + dist;
ensures keep_short_fp(buckets_put_key_fp(buckets, k, start, dist)) ==
        keep_short_fp(buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_put_same_len(buckets, k, start, dist);
      switch(h) {
        case bucket(chains):
          if (start == 0) {
            assert filter((sup)((nat_lt)(length(buckets)), snd), chains) ==
                   filter((sup)((nat_lt)(length(buckets)), snd),
                          cons(pair(k, nat_of_int(dist)), chains));
          } else {
            buckets_put_key_keep_short_no_effect(t, k, start - 1, dist);
          }
      }
  }
}//took 3m

lemma void buckets_put_key_keep_long_swap<kt>(list<bucket<kt> > buckets,
                                              kt k, int start, int dist)
requires length(buckets) <= start + dist;
ensures keep_long_fp(buckets_put_key_fp(buckets, k, start, dist)) ==
        buckets_put_key_fp(keep_long_fp(buckets), k, start, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      buckets_put_same_len(buckets, k, start, dist);
      switch(h) {
        case bucket(chains):
          if (start == 0) {
            assert cons(pair(k, nat_of_int(dist)),
                        filter((sup)((nat_ge)(length(buckets)), snd), chains)) ==
                   filter((sup)((nat_ge)(length(buckets)), snd),
                          cons(pair(k, nat_of_int(dist)), chains));
          } else {
            buckets_put_key_keep_long_swap(t, k, start - 1, dist);
          }
      }
  }
}//took 15m


lemma void advance_acc_dec_mem<kt>(list<pair<kt, nat> > acc, nat n)
requires true;
ensures mem(n, map(snd, advance_acc(acc))) ==
        mem(succ(n), map(snd, acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
            case succ(m):
          }
          advance_acc_dec_mem(t, n);
      }
  }
}


lemma void no_chain_in_wraparound_not_here<kt>(list<pair<kt, nat> > acc,
                                               list<bucket<kt> > buckets,
                                               int dist)
requires false == mem(nat_of_int(dist - length(buckets)),
                      map(snd, get_wraparound(acc, buckets))) &*&
         length(buckets) <= dist;
ensures false == mem(nat_of_int(dist), map(snd, acc));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      no_chain_in_wraparound_not_here(advance_acc(atb), t, dist - 1);
      assert false == mem(nat_of_int(dist - 1),
                          map(snd, advance_acc(atb)));
      if (mem(nat_of_int(dist), map(snd, acc))) {
        switch(h) {
          case bucket(chains):
            map_append(snd, acc, chains);
            mem_append(nat_of_int(dist), map(snd, acc), map(snd, chains));
            assert true == mem(nat_of_int(dist), map(snd, atb));
        }
        assert succ(nat_of_int(dist - 1)) == nat_of_int(dist);
        advance_acc_dec_mem(atb, nat_of_int(dist - 1));
        assert true == mem(nat_of_int(dist - 1),
                           map(snd, advance_acc(atb)));

        assert false;
      }
  }
}//took 15m

        lemma void
        acc_add_chain_abscent_in_wraparound_buckets_ok_rec<kt>
        (list<pair<kt, nat> > acc,
         list<bucket<kt> > buckets,
         kt k, int dist,
         int bound)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         length(buckets) <= dist &*& dist < bound - 1 &*&
         false == mem(nat_of_int(dist - length(buckets)),
                      map(snd, get_wraparound(acc, buckets)));
ensures true == buckets_ok_rec(cons(pair(k, nat_of_int(dist)), acc),
                               buckets, bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
      list<pair<kt, nat> > new_acc_atb =
      acc_at_this_bucket(cons(pair(k, nat_of_int(dist)), acc), h);
      cons_acc_atb_swap(acc, h, pair(k, nat_of_int(dist)));
      assert new_acc_atb == cons(pair(k, nat_of_int(dist)), acc_atb);
      no_chain_in_wraparound_not_here(advance_acc(acc_atb), t, dist-1);
      advance_acc_keeps_tail_mem(acc_atb, nat_of_int(dist - 1));
      assert true == distinct(map(snd, new_acc_atb));
      acc_add_chain_abscent_in_wraparound_buckets_ok_rec
      (advance_acc(acc_atb),
       t, k, dist - 1, bound);
      assert advance_acc(new_acc_atb) ==
             cons(pair(k, nat_of_int(dist - 1)),
                  advance_acc(acc_atb));
      assert true == buckets_ok_rec(advance_acc(new_acc_atb), t, bound);
  }
}

lemma void long_buckets_put_still_ok_rec<kt>(list<pair<kt, nat> > acc,
                                             list<bucket<kt> > buckets,
                                             kt k, int start, int dist,
                                             int bound)
requires true == buckets_ok_rec(acc, buckets, bound) &*&
         true == buckets_long_fp(buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*& dist < bound &*&
         length(buckets) <= start + dist &*&
         false == mem(nat_of_int(start + dist - length(buckets)),
                      map(snd, get_wraparound(acc, buckets)));
ensures true == buckets_ok_rec(acc, buckets_put_key_fp(buckets, k,
                                                       start, dist),
                               bound);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      if (start == 0) {
        list<pair<kt, nat> > acc_atb = acc_at_this_bucket(acc, h);
        list<pair<kt, nat> > new_acc_atb =
        acc_at_this_bucket(acc, bucket_put_key_fp(h, k, dist));
        acc_at_bucket_put_is_cons(acc, h, k, dist);
        assert true == forall(cons(pair(k, nat_of_int(dist)), acc_atb),
                              (sup)((nat_lt)(bound), snd));
        set_eq_forall_both(cons(pair(k, nat_of_int(dist)), acc_atb),
                           new_acc_atb,
                           (sup)((nat_lt)(bound), snd));
        assert true == forall(new_acc_atb, (sup)((nat_lt)(bound), snd));
        assert true == distinct(map(snd, acc_atb));
        no_chain_in_wraparound_not_here(advance_acc(acc_atb), t, dist-1);
        assert false == mem(nat_of_int(dist-1),
                            map(snd, advance_acc(acc_atb)));
        advance_acc_keeps_tail_mem(acc_atb, nat_of_int(dist - 1));
        assert false == mem(nat_of_int(dist), map(snd, acc_atb));
        assert length(cons(pair(k, nat_of_int(dist)), acc_atb)) ==
               length(new_acc_atb);

        accs_eq_tails_distinct(cons(pair(k, nat_of_int(dist)), acc_atb),
                               new_acc_atb);
        assert true == distinct(map(snd, new_acc_atb));
        acc_add_chain_abscent_in_wraparound_buckets_ok_rec
        (advance_acc(acc_atb), t, k, dist - 1, bound);
        advance_acc_still_eq(cons(pair(k, nat_of_int(dist)), acc_atb),
                             new_acc_atb);
        advance_acc_still_distinct(new_acc_atb);
        acc_eq_buckets_ok_rec(advance_acc(cons(pair(k, nat_of_int(dist)),
                                               acc_atb)),
                              advance_acc(new_acc_atb),
                              t, bound);
        assert true == buckets_ok_rec(advance_acc(new_acc_atb), t, bound);
      } else {
        switch(h) {
          case bucket(chains):
            long_buckets_put_still_ok_rec
            (advance_acc(acc_at_this_bucket(acc, h)),
             t, k, start - 1, dist, bound);
        }
      }
  }
}

lemma void acc_bounded_still_no_chain_in_wraparound<kt>(list<pair<kt, nat> > acc,
                                                        list<pair<kt, nat> > more_acc,
                                                        list<bucket<kt> > buckets,
                                                        nat chain)
requires false == mem(chain, map(snd,
                                 get_wraparound(acc,
                                                buckets))) &*&
         true == forall(more_acc, (sup)((nat_lt)(length(buckets) - 1), snd));
ensures false == mem(chain, map(snd,
                                get_wraparound(append(more_acc, acc),
                                               buckets)));
{
  forall_sup_map(more_acc, (nat_lt)(length(buckets) - 1), snd);
  short_chains_dont_matter(more_acc, acc, buckets, length(buckets) - 1,
                           length(buckets) - 1);
  wraparound_is_last_crossing_chains(acc, buckets);
  wraparound_is_last_crossing_chains(append(more_acc, acc), buckets);
}

lemma void content_eq_same_mem_wraparound<kt>(list<pair<kt, nat> > acc1,
                                              list<pair<kt, nat> > acc2,
                                              list<bucket<kt> > buckets,
                                              nat chain)
requires true == set_eq(acc1, acc2);
ensures mem(chain, map(snd, get_wraparound(acc1, buckets))) ==
        mem(chain, map(snd, get_wraparound(acc2, buckets)));
{
  switch(buckets) {
    case nil:
      content_eq_map(acc1, acc2, snd);
      if (mem(chain, map(snd, get_wraparound(acc1, buckets)))) {
        subset_mem_trans(map(snd, acc1), map(snd, acc2), chain);
      }
      if (mem(chain, map(snd, get_wraparound(acc2, buckets)))) {
        subset_mem_trans(map(snd, acc2), map(snd, acc1), chain);
      }
    case cons(h,t):
      list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
      list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
      acc_at_this_bucket_still_eq(acc1, acc2, h);
      advance_acc_still_eq(atb1, atb2);
      content_eq_same_mem_wraparound(advance_acc(atb1), advance_acc(atb2),
                                     t, chain);
  }
}//took 5m

lemma void advance_acc_keys_none<kt>(list<pair<kt, nat> > acc)
requires get_current_key_fp(acc) == none;
ensures map(fst, acc) == map(fst, advance_acc(acc));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              advance_acc_keys_none(t);
          }
      }
  }
}//took 3m

lemma void acc_decompose_curr_key_advance_acc_keys<kt>(list<pair<kt, nat> > acc,
                                                       kt k)
requires get_current_key_fp(acc) == some(k) &*&
         true == distinct(map(snd, acc));
ensures true == multiset_eq(map(fst, acc),
                            cons(k, map(fst, advance_acc(acc))));
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              assert key == k;
              assert false == mem(zero, map(snd, t));
              nozero_no_current_key(t);
              assert get_current_key_fp(t) == none;
              advance_acc_keys_none(t);
              multiset_eq_refl(map(fst, t));
            case succ(n):
              acc_decompose_curr_key_advance_acc_keys(t, k);
          }
      }
  }
}//took 12m

lemma void buckets_all_keys_decompose_some<kt>(list<pair<kt, nat> > acc,
                                               bucket<kt> bucket,
                                               list<bucket<kt> > rest)
requires get_current_key_fp(acc_at_this_bucket(acc, bucket)) == some(?k) &*&
         true == distinct(map(snd, acc_at_this_bucket(acc, bucket)));
ensures true == multiset_eq(append(map(fst, acc),
                                   buckets_all_keys_fp(cons(bucket,rest))),
                            cons(k, append(map(fst,
                                               advance_acc(
                                                 acc_at_this_bucket(acc,
                                                                    bucket))),
                                        buckets_all_keys_fp(rest))));
{
  switch(bucket) {
    case bucket(chains):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, bucket);
      acc_decompose_curr_key_advance_acc_keys(atb, k);

      assert true == multiset_eq(map(fst, atb),
                                 cons(k, map(fst, advance_acc(atb))));
      multiset_eq_append_both(map(fst, atb), cons(k, map(fst, advance_acc(atb))),
                              buckets_all_keys_fp(rest));
      map_append(fst, acc, chains);
      append_append_assoc(map(fst, acc), map(fst, chains),
                          buckets_all_keys_fp(rest));
      assert append(map(fst, atb), buckets_all_keys_fp(rest)) ==
             append(map(fst, acc), buckets_all_keys_fp(cons(bucket, rest)));

  }

}//took 16m

lemma void buckets_all_keys_decompose_none<kt>(list<pair<kt, nat> > acc,
                                               bucket<kt> bucket,
                                               list<bucket<kt> > rest)
requires get_current_key_fp(acc_at_this_bucket(acc, bucket)) == none;
ensures true == multiset_eq(append(map(fst, acc),
                                   buckets_all_keys_fp(cons(bucket,rest))),
                            append(map(fst,
                                       advance_acc(acc_at_this_bucket(acc,
                                                                      bucket))),
                                   buckets_all_keys_fp(rest)));
{
  switch(bucket) {
    case bucket(chains):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, bucket);
      advance_acc_keys_none(atb);
      // VVV multiset-eq list manipulation boilerplate
      multiset_eq_refl(append(map(fst, acc),
                              buckets_all_keys_fp(cons(bucket, rest))));
      assert true == multiset_eq(append(map(fst, acc),
                                        buckets_all_keys_fp(cons(bucket, rest))),
                                 append(map(fst, acc),
                                        append(map(fst, chains),
                                               buckets_all_keys_fp(rest))));
      multiset_eq_append_assoc(map(fst, acc), map(fst, chains),
                               buckets_all_keys_fp(rest));
      multiset_eq_comm(append(append(map(fst, acc), map(fst, chains)),
                              buckets_all_keys_fp(rest)),
                       append(map(fst, acc),
                              append(map(fst, chains),
                                     buckets_all_keys_fp(rest))));
      multiset_eq_trans(append(map(fst, acc),
                               buckets_all_keys_fp(cons(bucket, rest))),
                        append(map(fst, acc),
                               append(map(fst, chains),
                                      buckets_all_keys_fp(rest))),
                        append(append(map(fst, acc),
                                      map(fst, chains)),
                               buckets_all_keys_fp(rest)));
      assert true == multiset_eq(append(map(fst, acc),
                                        buckets_all_keys_fp(cons(bucket, rest))),
                                 append(append(map(fst, acc),
                                               map(fst, chains)),
                                        buckets_all_keys_fp(rest)));
      map_append(fst, acc, chains);
      multiset_eq_refl(map(fst, atb));
      multiset_eq_append_both(append(map(fst, acc), map(fst, chains)),
                              map(fst, atb),
                              buckets_all_keys_fp(rest));
      multiset_eq_trans(append(map(fst, acc),
                               buckets_all_keys_fp(cons(bucket, rest))),
                        append(append(map(fst, acc),
                                      map(fst, chains)),
                               buckets_all_keys_fp(rest)),
                        append(map(fst, atb),
                               buckets_all_keys_fp(rest)));
      assert true == multiset_eq(append(map(fst, acc),
                                        buckets_all_keys_fp(cons(bucket, rest))),
                                 append(map(fst, atb),
                                        buckets_all_keys_fp(rest)));
      assert true == multiset_eq(append(map(fst, acc),
                                        buckets_all_keys_fp(cons(bucket, rest))),
                                 append(map(fst, advance_acc(atb)),
                                        buckets_all_keys_fp(rest)));

  }
}// took 25m

lemma void lift_upper_bound<kt>(list<pair<kt, nat> > l, int x, int y)
requires true == forall(l, (sup)((nat_lt)(x), snd)) &*& x <= y;
ensures true == forall(l, (sup)((nat_lt)(y), snd));
{
  switch(l) {
    case nil:
    case cons(h,t):
      lift_upper_bound(t, x, y);
  }
}

lemma void no_key_in_ks_no_key_in_buckets_short_rec<kt>(list<pair<kt, nat> > acc,
                                                        list<bucket<kt> > buckets,
                                                        kt k,
                                                        int bound)
requires false == mem(some(k), buckets_get_keys_rec_fp(acc, buckets)) &*&
         true == buckets_short_fp(buckets) &*&
         true == forall(acc, (sup)((nat_lt)(length(buckets)), snd)) &*&
         true == buckets_ok_rec(acc, buckets, bound);
ensures false == mem(k, buckets_all_keys_fp(buckets)) &*&
        false == mem(k, map(fst, acc));
{
  switch(buckets) {
    case nil:
      upper_limit_nonpos_no_tail(acc, 0);
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      switch(h) {
        case bucket(chains):
          forall_append(acc, chains,
                        (sup)((nat_lt)(length(buckets)), snd));
          advance_acc_lower_limit(atb, length(buckets));
          no_key_in_ks_no_key_in_buckets_short_rec(advance_acc(atb),
                                                   t, k, bound);
          switch(get_current_key_fp(atb)) {
            case none:
              buckets_all_keys_decompose_none(acc, h, t);
              multiset_eq_mem(k, append(map(fst, acc),
                                        buckets_all_keys_fp(buckets)),
                              append(map(fst, advance_acc(atb)),
                                     buckets_all_keys_fp(t)));
            case some(cur_k):
              buckets_all_keys_decompose_some(acc, h, t);
              multiset_eq_mem(k, append(map(fst, acc),
                                        buckets_all_keys_fp(buckets)),
                              cons(cur_k,
                                   append(map(fst, advance_acc(atb)),
                                          buckets_all_keys_fp(t))));
          }
          mem_append(k, map(fst, acc), buckets_all_keys_fp(buckets));
      }
  }
}// took 36m

lemma void all_keys_in_short_and_wraparound<kt>(list<bucket<kt> > buckets)
requires true;
ensures true == multiset_eq(buckets_all_keys_fp(buckets),
                            append(buckets_all_keys_fp(keep_short_fp(buckets)),
                                   map(fst, get_wraparound(nil, buckets))));
{
  buckets_split_all_keys(buckets);
  keep_long_indeed_long(buckets);
  keep_long_same_wraparound(nil, buckets);
  long_buckets_all_keys_in_wraparound(keep_long_fp(buckets));
  list<kt> shrt_keys = buckets_all_keys_fp(keep_short_fp(buckets));
  list<kt> lng_keys = buckets_all_keys_fp(keep_long_fp(buckets));
  list<kt> wrp_keys = map(fst, get_wraparound(nil, buckets));
  assert true == multiset_eq(append(shrt_keys, lng_keys),
                             buckets_all_keys_fp(buckets));
  assert true == multiset_eq(wrp_keys, lng_keys);
  multiset_eq_refl(shrt_keys);
  multiset_eq_append(shrt_keys, shrt_keys,
                     wrp_keys, lng_keys);
  multiset_eq_trans(append(shrt_keys, wrp_keys),
                    append(shrt_keys, lng_keys),
                    buckets_all_keys_fp(buckets));
  multiset_eq_comm(append(shrt_keys, wrp_keys),
                   buckets_all_keys_fp(buckets));
}//took 11m

lemma void no_key_in_ks_no_key_in_buckets<kt>(list<bucket<kt> > buckets, kt k)
requires false == mem(some(k), buckets_get_keys_fp(buckets)) &*&
         true == buckets_ok(buckets);
ensures false == mem(k, buckets_all_keys_fp(buckets));
{
  keep_short_same_len(buckets);
  buckets_ok_short_long_ok(get_wraparound(nil, buckets),
                           buckets, length(buckets));
  buckets_short_get_keys_rec(get_wraparound(nil, buckets), buckets);
  keep_short_indeed_short(buckets);
  buckets_ok_wraparound_bounded(buckets);
  lift_upper_bound(get_wraparound(nil, buckets),
                   length(buckets) - 1,
                   length(buckets));
  no_key_in_ks_no_key_in_buckets_short_rec(get_wraparound(nil, buckets),
                                           keep_short_fp(buckets),
                                           k,
                                           length(buckets));
  mem_append(k,
             buckets_all_keys_fp(keep_short_fp(buckets)),
             map(fst, get_wraparound(nil, buckets)));
  all_keys_in_short_and_wraparound(buckets);
  multiset_eq_mem(k,
                  buckets_all_keys_fp(buckets),
                  append(buckets_all_keys_fp(keep_short_fp(buckets)),
                         map(fst, get_wraparound(nil, buckets))));
}//took 30m

lemma void buckets_put_keys_disjoint<kt>(list<kt> ks,
                                         list<bucket<kt> > buckets,
                                         kt k, int start, int dist)
requires true == disjoint(ks, buckets_all_keys_fp(buckets)) &*&
         false == mem(k, ks);
ensures true == disjoint(ks,
                         buckets_all_keys_fp(buckets_put_key_fp(buckets, k,
                                                                start, dist)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
          } else {
            disjoint_unappend(nil, ks, map(fst, chains),
                              buckets_all_keys_fp(t));
            buckets_put_keys_disjoint(ks, t, k, start - 1, dist);
            disjoint_append(nil, ks, map(fst, chains),
                            buckets_all_keys_fp(buckets_put_key_fp(t, k,
                                                                   start - 1,
                                                                   dist)));
          }
      }
  }
}//took 10m

lemma void buckets_put_keys_distinct<kt>(list<bucket<kt> > buckets,
                                         kt k,
                                         int start,
                                         int dist)
requires true == distinct(buckets_all_keys_fp(buckets)) &*&
         false == mem(k, buckets_all_keys_fp(buckets));
ensures true == distinct(buckets_all_keys_fp(buckets_put_key_fp(buckets,
                                                                k,
                                                                start,
                                                                dist)));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          if (start == 0) {
          } else {
            distinct_unappend(map(fst, chains), buckets_all_keys_fp(t));
            disjoint_comm(map(fst, chains),
                          buckets_all_keys_fp(t));
            buckets_put_keys_disjoint(map(fst, chains), t,
                                      k, start - 1, dist);
            buckets_put_keys_distinct(t, k, start - 1, dist);
            distinct_and_disjoint_append(map(fst, chains),
                                         buckets_all_keys_fp(
                                           buckets_put_key_fp(t, k,
                                                              start - 1,
                                                              dist)));
        }
      }
  }
}//took 16m

lemma void buckets_put_still_ok<kt>(list<bucket<kt> > buckets,
                                    kt k, int start, int dist)
requires true == buckets_ok(buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*& dist < length(buckets) &*&
         false == mem(k, buckets_all_keys_fp(buckets)) &*&
         nth(loop_fp(start + dist, length(buckets)),
             buckets_get_keys_fp(buckets)) == none;
ensures true == buckets_ok(buckets_put_key_fp(buckets, k, start, dist));
{
  buckets_put_same_len(buckets, k, start, dist);
  buckets_put_keys_distinct(buckets, k, start, dist);
  if (length(buckets) <= start + dist) {
    assert true == buckets_ok_rec(get_wraparound(nil, buckets), buckets, length(buckets));
    buckets_put_wraparound_is_cons(nil, buckets, k, start, dist);
    loop_injection_n(start + dist - length(buckets), length(buckets), 1);
    loop_bijection(start + dist - length(buckets), length(buckets));
    acc_add_chain_buckets_ok_rec(get_wraparound(nil, buckets),
                                 buckets,
                                 k, start + dist - length(buckets),
                                 length(buckets));
    buckets_ok_rec_wraparound_distinct(get_wraparound(nil, buckets),
                                       buckets, length(buckets));
    buckets_ok_get_wraparound_idemp(buckets);
    assert true == distinct(map(snd, get_wraparound(nil, buckets)));
    nat dist_left = nat_of_int(start + dist - length(buckets));
    get_key_none_no_chain(get_wraparound(nil, buckets), buckets,
                          start + dist - length(buckets));
    assert false == mem(dist_left,
                        map(snd, get_wraparound(nil, buckets)));
    accs_eq_tails_distinct
    (cons(pair(k, nat_of_int(start + dist - length(buckets))),
          get_wraparound(nil, buckets)),
     get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)));
    acc_eq_buckets_ok_rec(cons(pair(k, nat_of_int(start + dist - length(buckets))),
                               get_wraparound(nil, buckets)),
                          get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
                          buckets,
                          length(buckets));
    assert true == buckets_ok_rec(get_wraparound(nil,
                                                 buckets_put_key_fp(buckets, k,
                                                                    start, dist)),
                                  buckets, length(buckets));
    buckets_ok_short_long_ok
    (get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
     buckets, length(buckets));
    buckets_put_key_keep_short_no_effect(buckets, k, start, dist);
    buckets_put_key_keep_long_swap(buckets, k, start, dist);
    keep_long_indeed_long(buckets);
    keep_long_same_len(buckets);
    buckets_put_wraparound_is_cons(nil, buckets, k, start, dist);
    assert true == set_eq
           (get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
            cons(pair(k, nat_of_int(start + dist - length(buckets))),
                 get_wraparound(nil, buckets)));
    buckets_ok_wraparound_bounded(buckets);
    assert true == forall(get_wraparound(nil, buckets),
                          (sup)((nat_lt)(length(buckets) - 1), snd));
    assert true == forall(cons(pair(k, dist_left),
                               get_wraparound(nil, buckets)),
                          (sup)((nat_lt)(length(buckets) - 1), snd));
    acc_bounded_still_no_chain_in_wraparound
    (nil,
     cons(pair(k, dist_left), get_wraparound(nil, buckets)),
     buckets,
     dist_left);
    assert append(cons(pair(k, dist_left), get_wraparound(nil, buckets)), nil) ==
           cons(pair(k, dist_left), get_wraparound(nil, buckets));
    assert false == mem(dist_left,
                        map(snd,
                            get_wraparound(cons(pair(k, dist_left),
                                                get_wraparound(nil, buckets)),
                                           buckets)));
    content_eq_same_mem_wraparound
    (cons(pair(k, dist_left), get_wraparound(nil, buckets)),
     get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
     buckets,
     dist_left);
    assert false == mem(dist_left,
                        map(snd, 
                            get_wraparound
                            (get_wraparound(nil, buckets_put_key_fp(buckets,
                                                                    k, start,
                                                                    dist)),
                             buckets)));
    keep_long_same_wraparound(
      get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
      buckets);
    long_buckets_put_still_ok_rec(
      get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
      keep_long_fp(buckets), k, start, dist, length(buckets));
    buckets_split_ok_orig_ok(get_wraparound(nil, buckets_put_key_fp(buckets,
                                                                    k,
                                                                    start,
                                                                    dist)),
                             buckets_put_key_fp(buckets, k, start, dist),
                             length(buckets));
  } else {
    buckets_put_short_chain_same_wraparound(nil, buckets, k,
                                            start, dist,
                                            length(buckets));
    assert get_wraparound(nil, buckets_put_key_fp(buckets, k,
                                                  start, dist)) ==
           get_wraparound(nil, buckets);
    buckets_ok_short_long_ok
    (get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
     buckets, length(buckets));
    keep_short_indeed_short(buckets);
    keep_short_same_len(buckets);
    loop_bijection(start + dist, length(buckets));
    no_key_especially_in_short_and_long(
      get_wraparound(nil, buckets_put_key_fp(buckets, k, start,
                                             dist)),
      buckets,
      start + dist);
    short_buckets_put_still_ok_rec(
      get_wraparound(nil, buckets_put_key_fp(buckets, k, start,
                                             dist)),
      keep_short_fp(buckets), k, start, dist, length(buckets));
    buckets_put_key_keep_short_swap(buckets, k, start, dist);
    buckets_put_key_keep_long_no_effect(buckets, k, start, dist);
    buckets_split_ok_orig_ok(get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
                             buckets_put_key_fp(buckets, k, start, dist), length(buckets));
    assert true == buckets_ok_rec(get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
                                  buckets_put_key_fp(buckets, k, start, dist),
                                  length(buckets));
    assert true == buckets_ok_rec(get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
                                  buckets_put_key_fp(buckets, k, start, dist),
                                  length(buckets_put_key_fp(buckets, k, start, dist)));
  }
}

lemma void remove_chain_get_current_key<kt>(list<pair<kt, nat> > acc,
                                            kt k, nat dst)
requires dst != zero;
ensures get_current_key_fp(remove(pair(k, dst), acc)) ==
        get_current_key_fp(acc);
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
              if (h != pair(k, dst))
              remove_chain_get_current_key(t, k, dst);
          }
      }
  }
}

lemma void acc_eq_same_cur_key<kt>(list<pair<kt, nat> > acc1,
                                   list<pair<kt, nat> > acc2)
requires true == distinct(map(snd, acc1)) &*&
         true == distinct(map(snd, acc2)) &*&
         true == set_eq(acc1, acc2);
ensures get_current_key_fp(acc1) == get_current_key_fp(acc2);
{
  switch(acc1) {
    case nil:
      subset_nil_nil(acc2);
    case cons(h,t):
      switch(h) {
        case pair(key, dist):
          switch(dist) {
            case zero:
              subset_mem_trans(acc1, acc2, h);
              distinct_and_zero_this_is_the_key(acc2, key);
            case succ(n):
              distinct_unmap(acc1, snd);
              distinct_unmap(acc2, snd);
              set_eq_remove_both(acc1, acc2, h);
              distinct_map_remove(acc2, snd, h);
              remove_chain_get_current_key(acc2, key, dist);
              acc_eq_same_cur_key(t, remove(h, acc2));
          }
      }
  }
}


lemma void acc_eq_same_ks<kt>(list<pair<kt, nat> > acc1,
                              list<pair<kt, nat> > acc2,
                              list<bucket<kt> > buckets,
                              int bound)
requires true == set_eq(acc1, acc2) &*&
         true == distinct(map(snd, acc2)) &*&
         true == buckets_ok_rec(acc1, buckets, bound);
ensures buckets_get_keys_rec_fp(acc1, buckets) ==
        buckets_get_keys_rec_fp(acc2, buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
      list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
      acc_at_this_bucket_still_eq(acc1, acc2, h);

      switch(h) {
        case bucket(chains):
          map_append(snd, acc1, chains);
          map_append(snd, acc2, chains);
          subset_map(acc2, acc1, snd);
          subset_append_distinct(map(snd, acc2),
                                 map(snd, acc1),
                                 map(snd, chains));
      }
      assert true == distinct(map(snd, atb1));
      assert true == distinct(map(snd, atb2));
      acc_eq_same_cur_key(atb1, atb2);
      assert get_current_key_fp(atb1) ==
             get_current_key_fp(atb2);
      advance_acc_still_eq(atb1, atb2);
      assert true == set_eq(advance_acc(atb1), advance_acc(atb2));
      advance_acc_still_distinct(atb2);
      acc_eq_same_ks(advance_acc(atb1), advance_acc(atb2),
                     t, bound);
  }
}



lemma void single_elem_cur_key_is_none<kt>(list<pair<kt, nat> > acc,
                                           kt k, nat dst)
requires true == subset(acc, cons(pair(k, dst), nil)) &*&
         dst != zero;
ensures get_current_key_fp(acc) == none;
{
  switch(acc) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      assert h == pair(k, dst);
      single_elem_cur_key_is_none(t, k, dst);
  }
}

lemma void cons_content_eq_same_cur_key<kt>(list<pair<kt, nat> > acc1,
                                            list<pair<kt, nat> > acc2,
                                            kt k, nat dst)
requires true == set_eq(cons(pair(k, dst), acc1), acc2) &*&
         false == mem(dst, map(snd, acc1)) &*&
         true == distinct(map(snd, acc2)) &*&
         true == distinct(map(snd, acc1)) &*&
         dst != zero;
ensures get_current_key_fp(acc1) == get_current_key_fp(acc2);
{
  switch(acc1) {
    case nil:
      single_elem_cur_key_is_none(acc2, k, dst);
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
              assert true == mem(h, acc2);
              distinct_and_zero_this_is_the_key(acc2, key);
            case succ(n):
              distinct_map_remove(acc2, snd, h);
              assert remove(h, cons(pair(k, dst), acc1)) ==
                     cons(pair(k, dst), t);
              distinct_unmap(acc1, snd);
              distinct_unique(acc1, h);
              distinct_unmap(acc2, snd);
              distinct_unique(acc2, h);
              if (h == pair(k, dst)) {
                assert true == mem(dst, map(snd, acc1));
              }
              assert false == mem(h, remove(h, cons(pair(k, dst), acc1)));
              set_eq_remove_uniq_both(cons(pair(k, dst), acc1), acc2, h);
              cons_content_eq_same_cur_key(t, remove(h, acc2), k, dst);
              remove_chain_get_current_key(acc2, key, dist);
          }
      }
  }
}//took 40m

lemma void cons_content_eq_this_cur_key<kt>(list<pair<kt, nat> > acc1,
                                            list<pair<kt, nat> > acc2,
                                            kt k)
requires true == set_eq(cons(pair(k, zero), acc1), acc2) &*&
         true == distinct(map(snd, acc2));
ensures get_current_key_fp(acc2) == some(k);
{
  subset_mem_trans(cons(pair(k, zero), acc1), acc2, pair(k, zero));
  distinct_and_zero_this_is_the_key(acc2, k);
}

lemma void acc_eq_cons_update_ks<kt>(list<pair<kt, nat> > acc1,
                                     list<pair<kt, nat> > acc2,
                                     list<bucket<kt> > buckets,
                                     kt k,
                                     int dist,
                                     int bound)
requires true == set_eq(cons(pair(k, nat_of_int(dist)), acc1), acc2) &*&
         0 <= dist &*& dist < length(buckets) &*&
         nth(dist, buckets_get_keys_rec_fp(acc1, buckets)) == none &*&
         true == buckets_ok_rec(acc1, buckets, bound) &*&
         length(acc1) + 1 == length(acc2);
ensures buckets_get_keys_rec_fp(acc2, buckets) ==
        update(dist, some(k), buckets_get_keys_rec_fp(acc1, buckets));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb1 = acc_at_this_bucket(acc1, h);
      list<pair<kt, nat> > atb2 = acc_at_this_bucket(acc2, h);
      cons_acc_atb_swap(acc1, h, pair(k, nat_of_int(dist)));
      acc_at_this_bucket_still_eq(cons(pair(k, nat_of_int(dist)), acc1),
                                  acc2,
                                  h);
      assert true == set_eq(cons(pair(k, nat_of_int(dist)), atb1),
                            atb2);
      switch(h) {
        case bucket(chains):
          assert length(atb1) + 1 == length(atb2);
      }
      assert length(atb1) + 1 == length(atb2);
      if (dist == 0) {
        nozero_no_current_key(atb1);
      } else {
        get_key_none_no_chain(advance_acc(atb1), t, dist - 1);
        advance_acc_keeps_tail_mem(atb1, nat_of_int(dist-1));
      }
      accs_eq_tails_distinct(cons(pair(k, nat_of_int(dist)), atb1), atb2);
      advance_acc_still_eq(cons(pair(k, nat_of_int(dist)), atb1), atb2);
      advance_acc_still_distinct(atb2);

      if (dist == 0) {
        assert true == set_eq(advance_acc(atb1), advance_acc(atb2));
        cons_content_eq_this_cur_key(atb1, atb2, k);
        acc_eq_same_ks(advance_acc(atb1), advance_acc(atb2), t, bound);
      } else {
        cons_content_eq_same_cur_key(atb1, atb2, k, nat_of_int(dist));
        assert get_current_key_fp(cons(pair(k, nat_of_int(dist)), atb1)) ==
               get_current_key_fp(atb2);
        assert true == distinct(map(snd, atb1));
        assert true == distinct(map(snd, atb2));
        if (mem(pair(k, nat_of_int(dist)), atb1)) {
          mem_map(pair(k, nat_of_int(dist)), atb1, snd);
          assert true == mem(nat_of_int(dist), map(snd, atb2));
          assert false;
        }
        distinct_unmap(atb1, snd);
        assert true == distinct(atb1);
        assert true == distinct(cons(pair(k, nat_of_int(dist)), atb1));
        advance_acc_still_distinct(cons(pair(k, nat_of_int(dist)), atb1));
        advance_acc_still_distinct(atb2);
        distinct_unmap
        (advance_acc(cons(pair(k, nat_of_int(dist)), atb1)), snd);
        distinct_unmap
        (advance_acc(atb2), snd);
        set_eq_distinct_same_len
        (advance_acc(cons(pair(k, nat_of_int(dist)), atb1)),
         advance_acc(atb2));
        assert length(advance_acc(cons(pair(k, nat_of_int(dist)), atb1))) ==
               length(advance_acc(atb2));
        acc_eq_cons_update_ks(advance_acc(atb1), advance_acc(atb2),
                                          t, k, dist - 1, bound);
      }
  }
}//took 90m + 4 more lemmas

lemma void bucket_put_update_ks_nowraparound<kt>(list<pair<kt, nat> > acc,
                                                 list<bucket<kt> > buckets,
                                                 list<option<kt> > ks,
                                                 kt k, int start, int dist,
                                                 int bound)
requires ks == buckets_get_keys_rec_fp(acc, buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*& start + dist < length(buckets) &*&
         true == buckets_ok_rec(acc, buckets, bound) &*&
         nth(start + dist, buckets_get_keys_rec_fp(acc, buckets)) == none;
ensures update(start + dist, some(k), ks) ==
        buckets_get_keys_rec_fp(acc, buckets_put_key_fp(buckets, k,
                                                        start, dist));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      assert ks == cons(?ksh,?kst);
      if (start == 0) {
        list<pair<kt, nat> > new_atb =
        acc_at_this_bucket(acc,bucket_put_key_fp(h, k, dist));
        acc_at_bucket_put_is_cons(acc, h, k, dist);
        if (dist == 0) {
          nozero_no_current_key(atb);
        } else {
          get_key_none_no_chain(advance_acc(atb), t, dist - 1);
          advance_acc_keeps_tail_mem(atb, nat_of_int(dist-1));
        }
        accs_eq_tails_distinct(cons(pair(k, nat_of_int(dist)), atb), new_atb);
        assert true == distinct(map(snd, new_atb));
        advance_acc_still_distinct(cons(pair(k, nat_of_int(dist)), atb));
        advance_acc_still_distinct(new_atb);
        advance_acc_still_eq(cons(pair(k, nat_of_int(dist)), atb), new_atb);
        if (dist == 0) {
          cons_content_eq_this_cur_key(atb, new_atb, k);
          acc_eq_same_ks(advance_acc(atb), advance_acc(new_atb), t, bound);
        } else {
          assert true == set_eq(advance_acc(cons(pair(k, nat_of_int(dist)), atb)), advance_acc(new_atb));
          assert succ(nat_of_int(dist-1)) == nat_of_int(dist);
          assert advance_acc((cons(pair(k, nat_of_int(dist)), atb))) ==
                 cons(pair(k, nat_of_int(dist-1)), advance_acc(atb));
          assert true == set_eq(cons(pair(k, nat_of_int(dist-1)), advance_acc(atb)), advance_acc(new_atb));
          switch(h) {
            case bucket(chains):
              assert length(atb) + 1 == length(new_atb);
          }
          assert false == mem(nat_of_int(dist), map(snd, atb));
          assert true == distinct(map(snd, cons(pair(k, nat_of_int(dist)), atb)));
          assert true == distinct(map(snd, atb));
          distinct_unmap(advance_acc(cons(pair(k, nat_of_int(dist)), atb)),
                         snd);
          distinct_unmap(advance_acc(new_atb), snd);
          set_eq_distinct_same_len
          (advance_acc(cons(pair(k, nat_of_int(dist)), atb)),
           advance_acc(new_atb));
          acc_eq_cons_update_ks(advance_acc(atb), advance_acc(new_atb),
                                t, k, dist - 1, bound);
          cons_content_eq_same_cur_key(atb, new_atb, k, nat_of_int(dist));
          assert get_current_key_fp(atb) == get_current_key_fp(new_atb);
        }
      } else {
        bucket_put_update_ks_nowraparound(advance_acc(atb),
                                          t, kst, k, start - 1,
                                          dist, bound);
      }
  }
}//took 95m


lemma void buckets_put_update_ks<kt>(list<bucket<kt> > buckets,
                                     list<option<kt> > ks,
                                     kt k, int start, int dist)
requires ks == buckets_get_keys_fp(buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist &*& dist < length(buckets) &*&
         true == buckets_ok(buckets) &*&
         nth(loop_fp(start + dist, length(buckets)), ks) == none;
ensures update(loop_fp(start + dist, length(buckets)), some(k), ks) ==
        buckets_get_keys_fp(buckets_put_key_fp(buckets, k, start,
                                               dist));
{
  if (start + dist < length(buckets)) {
    loop_bijection(start + dist, length(buckets));
    buckets_put_short_chain_same_wraparound
    (nil, buckets, k,
     start, dist,
     length(buckets));
    bucket_put_update_ks_nowraparound
    (get_wraparound(nil, buckets), buckets,
     ks, k, start, dist,
     length(buckets));
  } else {
    loop_injection_n(start + dist - length(buckets), length(buckets), 1);
    loop_bijection(start + dist - length(buckets), length(buckets));
    buckets_short_get_keys_rec(get_wraparound(nil, buckets), buckets);
    assert buckets_get_keys_rec_fp(get_wraparound(nil, buckets), buckets) ==
           buckets_get_keys_rec_fp(get_wraparound(nil, buckets),
                                   keep_short_fp(buckets));
    list<bucket<kt> > bpt = buckets_put_key_fp(buckets, k, start, dist);
    buckets_put_key_keep_short_no_effect (buckets, k, start, dist);
    assert keep_short_fp(buckets) == keep_short_fp(bpt);
    buckets_short_get_keys_rec(get_wraparound(nil, bpt), bpt);
    assert buckets_get_keys_rec_fp(get_wraparound(nil, bpt),
                                   bpt) ==
           buckets_get_keys_rec_fp(get_wraparound(nil, bpt),
                                   keep_short_fp(bpt));
    assert buckets_get_keys_fp(bpt) ==
           buckets_get_keys_rec_fp(get_wraparound(nil, bpt),
                                   keep_short_fp(buckets));
    nat tail_left = nat_of_int(start + dist - length(buckets));
    buckets_put_wraparound_is_cons(nil, buckets, k, start, dist);
    assert true == set_eq(cons(pair(k, tail_left),
                               get_wraparound(nil, buckets)),
                          get_wraparound(nil, bpt));
    keep_short_same_len(buckets);
    buckets_ok_short_long_ok(get_wraparound(nil, buckets),
                             buckets,
                             length(buckets));
    acc_eq_cons_update_ks(get_wraparound(nil, buckets),
                          get_wraparound(nil, bpt),
                          keep_short_fp(buckets),
                          k,
                          start + dist - length(buckets),
                          length(buckets));
  }
}//took 15m+35m so far


lemma void advance_acc_eliminate_zero_chain<kt>(list<pair<kt, nat> > acc1,
                                                list<pair<kt, nat> > acc2,
                                                kt k)
requires true;
ensures advance_acc(append(acc1, cons(pair(k, zero), acc2))) ==
        advance_acc(append(acc1, acc2));
{
  switch(acc1) {
    case nil:
    case cons(h,t):
      switch(h) {
        case pair(key,dist):
          switch(dist) {
            case zero:
            case succ(n):
          }
      }
      advance_acc_eliminate_zero_chain(t, acc2, k);
  }
}


lemma void add_no_partial_chain_rec(list<int> chns)
requires true;
ensures add_partial_chain_rec_fp(chns, 0, 0) == chns;
{
  switch(chns) {
    case nil:
    case cons(h,t):
  }
}


lemma void buckets_add_part_get_chns_norm_rec<kt>(list<pair<kt, nat> > acc,
                                                  list<bucket<kt> > buckets,
                                                  kt k, int start, int dist)
requires start + dist <= length(buckets) &*&
         0 <= dist;
ensures buckets_get_chns_rec_fp(acc, buckets_put_key_fp(buckets, k,
                                                        start, dist)) ==
        add_partial_chain_rec_fp(buckets_get_chns_rec_fp(acc, buckets),
                                 start, dist);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          if (start == 0) {
            list<pair<kt, nat> > new_atb =
            acc_at_this_bucket(acc, bucket_put_key_fp(h, k, dist));
            assert new_atb == append(acc, cons(pair(k, nat_of_int(dist)), chains));
            cons_in_the_middle_multiset_eq(acc, chains,
                                           pair(k, nat_of_int(dist)));
            assert true == multiset_eq(new_atb, cons(pair(k, nat_of_int(dist)), atb));
            assert length(new_atb) == length(atb) + 1;
            if (dist == 0) {
              advance_acc_eliminate_zero_chain(acc, chains, k);
              assert advance_acc(atb) == advance_acc(new_atb);
              add_no_partial_chain_rec(buckets_get_chns_rec_fp(advance_acc(atb), t));
              assert add_partial_chain_rec_fp
                     (buckets_get_chns_rec_fp(advance_acc(atb), t),
                      start, dist) == buckets_get_chns_rec_fp(advance_acc(atb), t);
            } else {
              advance_acc_multiset_eq(new_atb,
                                      cons(pair(k, nat_of_int(dist)), atb));
              nat m = nat_of_int(dist - 1);
              assert succ(m) == nat_of_int(dist);
              assert true == multiset_eq(advance_acc(new_atb),
                                         cons(pair(k, nat_of_int(dist-1)),
                                              advance_acc(atb)));
              multiset_eq_same_len(advance_acc(new_atb), cons(pair(k, nat_of_int(dist-1)), advance_acc(atb)));
              assert length(advance_acc(new_atb)) == length(advance_acc(atb)) + 1;
              acc_eq_cons_get_chns_like_add_part_chn(advance_acc(new_atb),
                                                     advance_acc(atb),
                                                     t, k, dist - 1);
            }
          } else {
            buckets_add_part_get_chns_norm_rec(advance_acc(atb),
                                               t, k, start - 1, dist);
          }
      }
  }
}

lemma void buckets_add_part_get_chns_norm<kt>(list<bucket<kt> > buckets,
                                              kt k, int start, int dist)
requires start + dist < length(buckets) &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist;
ensures buckets_get_chns_fp(buckets_put_key_fp(buckets, k,
                                               start, dist)) ==
        add_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  buckets_put_short_chain_same_wraparound(nil, buckets,
                                          k, start, dist,
                                          length(buckets));
  buckets_add_part_get_chns_norm_rec(get_wraparound(nil, buckets),
                                     buckets, k, start, dist);
  buckets_keys_chns_same_len(buckets);
  buckets_put_same_len(buckets, k, start, dist);
  buckets_keys_chns_same_len(buckets_put_key_fp(buckets, k, start, dist));
}//took 200m

lemma void buckets_put_chain_lim_wraparound_add_zero_chain<kt>(list<pair<kt, nat> > acc,
                                                               list<bucket<kt> > buckets,
                                                               kt k, int start)
requires 0 <= start &*& start < length(buckets);
ensures true == multiset_eq
        (get_wraparound(acc, buckets_put_key_fp(buckets,
                                                k, start,
                                                length(buckets) -
                                                start)),
         cons(pair(k, zero), get_wraparound(acc, buckets)));
{
  buckets_put_wraparound_eq_cons(acc, buckets, k, start,
                                 length(buckets) - start);
}


lemma void buckets_add_part_get_chns_lim<kt>(list<bucket<kt> > buckets,
                                             kt k, int start)
requires 0 <= start &*& start < length(buckets);
ensures buckets_get_chns_fp(buckets_put_key_fp(buckets, k,
                                               start,
                                               length(buckets) - start)) ==
        add_partial_chain_fp(start, length(buckets) - start,
                             buckets_get_chns_fp(buckets));
{
  int dist = length(buckets) - start;
  buckets_keys_chns_same_len(buckets);
  buckets_put_same_len(buckets, k, start, dist);
  buckets_keys_chns_same_len(buckets_put_key_fp(buckets, k, start, dist));

  buckets_put_chain_lim_wraparound_add_zero_chain(nil, buckets, k, start);

  assert true == multiset_eq
         (get_wraparound(nil, buckets_put_key_fp(buckets, k, start,
                                                 length(buckets) - start)),
          cons(pair(k, zero), get_wraparound(nil, buckets)));
  acc_additional_zero_chain_same_chns
  (get_wraparound(nil, buckets_put_key_fp(buckets, k, start,
                                          length(buckets) - start)),
   get_wraparound(nil, buckets),
   buckets, k);
  buckets_add_part_get_chns_norm_rec(get_wraparound(nil, buckets),
                                     buckets, k, start,
                                     length(buckets) - start);
  acc_additional_zero_chain_same_chns
  (get_wraparound(nil, buckets_put_key_fp(buckets, k, start,
                                          length(buckets) - start)),
   get_wraparound(nil, buckets),
   buckets_put_key_fp(buckets, k, start, length(buckets) - start), k);
}


lemma void acc_add_overflow_all_same_chns<kt>(list<pair<kt, nat> > acc,
                                              list<pair<kt, nat> > orig,
                                              list<bucket<kt> > buckets,
                                              kt k, int dist)
requires length(buckets) <= dist &*&
         true == multiset_eq(acc, cons(pair(k, nat_of_int(dist)), orig));
ensures buckets_get_chns_rec_fp(acc, buckets) ==
        buckets_get_chns_rec_fp(cons(pair(k, nat_of_int(length(buckets))),
                                     orig),
                                buckets);
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      switch(h) {
        case bucket(chains):
          list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
          list<pair<kt, nat> > orig_atb = acc_at_this_bucket(orig, h);
          multiset_eq_append_both(acc, cons(pair(k, nat_of_int(dist)), orig),
                                  chains);
          advance_acc_multiset_eq(atb, cons(pair(k, nat_of_int(dist)),
                                            orig_atb));
          multiset_eq_same_len(advance_acc(atb),
                               advance_acc(cons(pair(k, nat_of_int(dist)),
                                                orig_atb)));
          int prev_dist = dist - 1;
          assert nat_of_int(dist) == succ(nat_of_int(prev_dist));
          acc_add_overflow_all_same_chns(advance_acc(atb),
                                         advance_acc(orig_atb),
                                         t, k, dist - 1);
          assert nat_of_int(length(buckets)) == succ(nat_of_int(length(t)));
      }
  }
}


lemma void put_overflow_chain_same_chns<kt>(list<pair<kt, nat> > acc,
                                            list<bucket<kt> > buckets,
                                            kt k, int start, int dist)
requires length(buckets) <= start + dist &*&
         0 <= dist;
ensures buckets_get_chns_rec_fp
        (acc, buckets_put_key_fp(buckets, k, start, dist)) ==
        buckets_get_chns_rec_fp
        (acc, buckets_put_key_fp(buckets, k, start,
                                 length(buckets) - start));
{
  switch(buckets) {
    case nil:
    case cons(h,t):
      list<pair<kt, nat> > atb = acc_at_this_bucket(acc, h);
      if (start == 0) {
        switch(h) {
          case bucket(chains):
            list<pair<kt, nat> > new_atb =
            acc_at_this_bucket(acc, bucket_put_key_fp(h, k, dist));
            list<pair<kt, nat> > primary_atb =
            acc_at_this_bucket
            (acc, bucket_put_key_fp(h, k, length(buckets) - start));
            cons_in_the_middle_multiset_eq(acc, chains, pair(k, nat_of_int(dist)));
            cons_in_the_middle_multiset_eq
            (acc, chains, pair(k, nat_of_int(length(buckets) - start)));
            assert 0 < dist;
            int prev_dist = dist - 1;
            assert 0 < length(buckets) - start;
            int prev_lim_dist = length(buckets) - start - 1;
            assert nat_of_int(dist) == succ(nat_of_int(prev_dist));
            assert nat_of_int(length(buckets) - start) ==
                   succ(nat_of_int(prev_lim_dist));
            advance_acc_multiset_eq(new_atb, cons(pair(k, nat_of_int(dist)), atb));
            advance_acc_multiset_eq(primary_atb,
                                    cons(pair(k, nat_of_int(length(buckets) -
                                                            start)),
                                         atb));
            multiset_eq_same_len(advance_acc(new_atb),
                                 advance_acc(cons(pair(k, nat_of_int(dist)),
                                                  atb)));
            multiset_eq_same_len(advance_acc(primary_atb),
                                 advance_acc
                                 (cons(pair(k, nat_of_int(length(buckets) -
                                                          start)),
                                       atb)));
            assert length(advance_acc(primary_atb)) ==
                   length(advance_acc(new_atb));
            acc_add_overflow_all_same_chns(advance_acc(new_atb), advance_acc(atb),
                                           t, k, dist - 1);
            acc_eq_get_chns_eq(advance_acc(primary_atb),
                               cons(pair(k, nat_of_int(length(t))),
                                    advance_acc(atb)),
                               t);
        }
      } else {
        put_overflow_chain_same_chns(advance_acc(atb), t, k, start - 1, dist);
      }
  }
}


lemma void buckets_add_part_get_chns_inv<kt>(list<bucket<kt> > buckets,
                                             kt k, int start, int dist)
requires length(buckets) < start + dist &*&
         0 <= start &*& start < length(buckets) &*&
         0 <= dist;
ensures buckets_get_chns_fp(buckets_put_key_fp(buckets, k,
                                               start, dist)) ==
        add_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  buckets_put_wraparound_eq_cons(nil, buckets, k, start, dist);
  assert true == multiset_eq
         (get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
          cons(pair(k, nat_of_int(dist + start - length(buckets))),
               get_wraparound(nil, buckets)));
  acc_eq_cons_get_chns_like_add_part_chn
  (get_wraparound(nil, buckets_put_key_fp(buckets, k, start, dist)),
   get_wraparound(nil, buckets),
   buckets_put_key_fp(buckets, k, start, dist),
   k, dist + start - length(buckets));
  put_overflow_chain_same_chns(get_wraparound(nil, buckets),
                               buckets, k, start, dist);
  assert buckets_get_chns_rec_fp
         (get_wraparound(nil, buckets),
          buckets_put_key_fp(buckets, k, start, dist)) ==
         buckets_get_chns_rec_fp
         (get_wraparound(nil, buckets),
          buckets_put_key_fp(buckets, k, start,
                             length(buckets) - start));
  buckets_add_part_get_chns_norm_rec(get_wraparound(nil, buckets),
                                     buckets,
                                     k, start,
                                     length(buckets) - start);
  assert buckets_get_chns_rec_fp
         (get_wraparound(nil, buckets),
          buckets_put_key_fp(buckets, k, start,
                             length(buckets) - start)) ==
         add_partial_chain_rec_fp
         (buckets_get_chns_rec_fp(get_wraparound(nil, buckets), buckets),
          start, length(buckets) - start);
  buckets_keys_chns_same_len_rec(get_wraparound(nil, buckets), buckets);
  add_part_chain_rec_overflow(buckets_get_chns_rec_fp
                              (get_wraparound(nil, buckets), buckets),
                              start, length(buckets) - start, dist);
  assert add_partial_chain_rec_fp
         (buckets_get_chns_rec_fp(get_wraparound(nil, buckets), buckets),
          start, length(buckets) - start) ==
         add_partial_chain_rec_fp
         (buckets_get_chns_rec_fp(get_wraparound(nil, buckets), buckets),
          start, dist);
}//took 240m

lemma void buckets_add_part_get_chns<kt>(list<bucket<kt> > buckets,
                                         kt k, int start, int dist)
requires 0 <= start &*& start < length(buckets) &*&
         0 <= dist;
ensures buckets_get_chns_fp(buckets_put_key_fp(buckets, k,
                                               start, dist)) ==
        add_partial_chain_fp(start, dist,
                             buckets_get_chns_fp(buckets));
{
  if (dist + start == length(buckets)) {
    buckets_add_part_get_chns_lim(buckets, k, start);
  } else if (length(buckets) < dist + start) {
    buckets_add_part_get_chns_inv(buckets, k, start, dist);
  } else {
    buckets_add_part_get_chns_norm(buckets, k, start, dist);
  }
}


#endif//CHAIN_BUCKETS_GH
