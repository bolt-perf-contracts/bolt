
## Overview
Validator consumes Klee-generated traces, data structure API specification and a decision procedure and decides whether the used symbolic model is valid under the usage context represented by the traces. The validation may have three outcomes: *valid*, *invalid* and *unknown*. They mean:

#### Valid
The used set of symbolic models exhibit all the behaviours described by the specifications for the given call sequences under the given assumptions (symbolic path-conditions). This answer confirms that if the user-application verified successfully, it will remain correct after replacement of the symbolic models by the certified implementations

#### Invalid
The given set of symbolic models is inconsistent with the specifications. Namely, there exists a call sequence in the provided context, where the specifications allow for a behaviours not covered by the given set of models. In this case other models should be used, or the specifications should be detaled.

#### Unknown
The provided decision procedure, which is a proof-generation algorithm is incapable to demonstrate that some of the given call sequences (generated with the symbolic models) can be performed with respect to the specifications. In this case either the decision procedure needs improvement, or some human-aid (annotations?) may help.

## Design

### Validator components

There are 4 tools that perform validation:

#### Prefix generator

The simplest part of the validator. It takes the call traces, builds execution-tree and extracts all the prefixes. May be implemented as a part of Klee export, and later-on Klee may directly generate the prefixes for performance reasons, since the execution-tree is a projection of the Klee full execution tree.

#### Converter

Converter takes each prefix, and with the help of a decision procedure generates the C source file with VeriFast annotations that will convince VeriFast later on that this call sequence is legit. It will probably use VeriFast itself to check different annotations. At the last call in the file, it will either generate an assertion ensuring that the spec-prescribed output matches the model generated one, or it will mark the point for the VeriFast to export output formulas for Comparator. In the latter case it will also generate a separate file expressing the output from the symbolic model.

#### VeriFast-based verificator

Based on VeriFast, it will take the C source file and check every step for compliance with the specification. At the end it will either just check the assertion, or export the output formulas for Comparator.

#### Comparator

For difficult cases, where the simple assertion is not sufficient, there will be need to check that model generated output covers the spec-generated one. Comparator takes two formulas and verifies that the model-output expresses at least all the outputs that the spec allows. In most cases a simple substitution engine or out of the shelf SMT-solver should be enough, but this is to be investigated.

### Validation steps

1. Klee exports API traces in "API trace format".

2. Prefix generator, in oCaml, reads API traces and generates API trace prefixes.

3. Converter takes API trace prefixes and generates a VeriFast input file with 0,1 or more dump-points. For 0 dump points this is it. For more dump points, it generates also expressions for the tip-call outputs, namely the tip-call-alternatives.ret-val, tip-call-alternatives.args.pointee-after, and tip-call-alternatives.ret-context.

4. VeriFast checks the input C file and for 0 dump points, it checks the assertions on the return value; for more dump points it dumps expressions for the tip-call outputs.

5. Comparator takes expressions for tip-call outputs generated by the Validator and VeriFast, generates queries for inclusion and solves them with the help of SMT-solvers.

### API trace format
S-expr.

*APITrace* := calls : CallNode+

*CallNode* := fun-name : Symbol, args : Arg+, ret: Ret?, call-context : Expr+, ret-context : Expr+

*Arg* := name : Symbol, value : Val, is-ptr : Bool, pointee : Ptee?

*Ptee* := is-fun-ptr : Bool, fun-name : Symbol?, before : Val?, after : Val?

*Ret* := value : Val, is-ptr : bool pointee : Ptee?

*Val* := full : Expr, break-down : Field*

*Field* := name : Symbol, value : Val

*Symbol* := string

*Bool* := true | false

*Expr* := SMTlib2 formatted formula

### API trace prefix format
S-expr.

*APITracePrefix* := history : CallNode+, tip-calls : CallNode+

#### Restriction

All tip-call-alternatives have the same fun-name, call-context, args.name, args.value, args.is-ptr, args.is-fun-ptr, args.fun-name, and args.pointee-before. They may differ therefore in args.pointee-after, ret-val and ret-context.


