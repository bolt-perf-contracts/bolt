(* Generated by Frama-C WP *)

Goal typed_erase_has_post_2.
Hint erase,has,property.
Proof.
unfold P_has_K, P_has_K, P_no_doubles.
intros i t t_1 a_1 a M1NEQI ZEROleI IleM LINKEDT SINtI NODUBS BUSY REGA REGA1;
intros SINTA SINTA1 ZEROleL LleM VALID SINTL HASK VALIDALLA VALIDALLA1 INV.
unfold "~" at 1.
intro CONTRA.
destruct HASK as [x H].
destruct H as [ZEROleX H].
destruct H as [XleM H].
destruct H as [XasI A1XNONZERO].
assert (x = i). {
 case (Z.eq_dec x i);[auto|intro XY].
 contradict XasI.
 apply NODUBS;auto.
}
destruct CONTRA as [y CONTRA].
destruct CONTRA as [ZEROleY CONTRA].
destruct CONTRA as [YleM CONTRA].
destruct CONTRA as [UPD NONZERO].
case (Z.eq_dec x y);intro XY.
- subst y.
  subst i.
  rewrite access_update in NONZERO.
  auto.
- subst i.
  rewrite access_update_neq in UPD;[|assert (shift_sint32 a y <>
                                             shift_sint32 a_1 x)
                                      by (apply INV;auto);auto].
  rewrite access_update_neq in NONZERO;[|injection;omega].
  contradict UPD.
  apply NODUBS;auto.
Qed.

Goal typed_find_empty_loop_inv_for_non_full_2_established.
Hint established,find_empty,non_full.
Proof.
Require Import Psatz.
unfold P_full.
intros i y t t1 t2 a.
intros H H0 H1 H2 NONFULL.
intros.
apply Classical_Pred_Type.not_all_ex_not in NONFULL.
destruct NONFULL as [x NONFULL].
apply Classical_Prop.imply_to_and in NONFULL.
destruct NONFULL as [XL0 NONFULL].
apply Classical_Prop.imply_to_and in NONFULL.
destruct NONFULL as [XLIM NOTBUSY].
apply Z.eq_dne in NOTBUSY.
case (Z_lt_le_dec i x);intro IXI.
- exists x.
  split;[auto|split];[auto with zarith|].
  rewrite <- (Q_loop_bijection x);auto.
- exists (x + 1000000).
  split;[lia|split];[lia|].
  rewrite Int.Comm.
  rewrite <- (Q_loop_injection x);[|auto].
  rewrite <- (Q_loop_bijection x);auto.
Qed.

Goal typed_find_key_loop_inv_for_has_2_established.
Hint established,find_key,has.
Proof.
Require Import Psatz.
intros y i z.
intros.
rename H6 into HAS.
unfold P_has_K in HAS.
destruct HAS as [x HAS].
destruct HAS as [ZEROleX HAS].
destruct HAS as [XleM HAS].
destruct HAS as [ZDEF NONZERO].
case (Z_lt_le_dec i x);intro IXI.
- exists x.
  split;[auto|split];[auto with zarith|].
  rewrite <- (Q_loop_bijection x);auto.
- exists (x + 1000000).
  split;[lia|split];[lia|].
  rewrite Int.Comm.
  rewrite <- (Q_loop_injection x);[|auto].
  rewrite <- (Q_loop_bijection x);auto.
Qed.

Goal typed_find_key_loop_inv_for_has_2_preserved.
Hint find_key,has,preserved.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_lemma_full_rec_full.
Hint full_rec_full,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_lemma_full_rec_size_rec.
Hint full_rec_size_rec,property.
Proof.
Require Import Psatz.
intros.

assert (forall x y:bool, x = y <-> (x = true <-> y = true)) as AS_TRUE. {
  intros.
  split.
  - intros.
    subst x.
    tauto.
  - destruct x;destruct y;intuition.
}
assert (forall n:nat, L_full_rec t a (Z.of_nat n) = 
                      Zeq_bool (Z.of_nat n) (L_size_rec t a (Z.of_nat n))) as INNAT. {
  intro n;rewrite AS_TRUE;revert n.
  induction n.
  - rewrite FixL_full_rec.
    rewrite FixL_size_rec.
    simpl.
    tauto.
  - rewrite Nat2Z.inj_succ.
    rewrite FixL_full_rec.
    rewrite FixL_size_rec.
    replace (Z.succ (Z.of_nat n) - 1) with (Z.of_nat n) by omega.
    replace (Zeq_bool 0 (Z.succ (Z.of_nat n))) with false.
    remember (Zeq_bool 0 (t .[ shift_sint32 a (Z.of_nat n)])) as f; destruct f.
    + symmetry in Heqf.
      rewrite <- Zeq_is_eq_bool in Heqf.
      split.
      * intuition.
      * assert (forall n:nat, L_size_rec t a (Z.of_nat n) <= Z.of_nat n) as SIZElim by admit.
        remember (Zeq_bool (Z.succ (Z.of_nat n)) (L_size_rec t a (Z.of_nat n))) as ff; destruct ff.
        symmetry in Heqff; rewrite <- Zeq_is_eq_bool in Heqff.
        unfold Z.succ in Heqff.
        assert (L_size_rec t a (Z.of_nat n) <= Z.of_nat n) by apply SIZElim.
        omega.
        intro CONTRA.
        contradict CONTRA.
        auto.
    + symmetry in Heqf;apply Zeq_bool_neq in Heqf.
      replace (Zeq_bool (Z.succ (Z.of_nat n)) (1 + L_size_rec t a (Z.of_nat n))) with 
              (Zeq_bool (Z.of_nat n) (L_size_rec t a (Z.of_nat n))).
      intuition.
      remember (Zeq_bool (Z.of_nat n) (L_size_rec t a (Z.of_nat n))) as EQ; destruct EQ.
      * symmetry in HeqEQ; rewrite <- Zeq_is_eq_bool in HeqEQ.
        symmetry; rewrite <- Zeq_is_eq_bool.
        omega.
      * symmetry in HeqEQ; apply Zeq_bool_neq in HeqEQ.
        Print Z.succ.
        SearchAbout (Z.succ _ <> Z.succ _).
        rewrite <- Z.succ_inj_wd_neg in HeqEQ.
        unfold Z.succ in HeqEQ.
        unfold Z.succ.
        remember (Zeq_bool (Z.of_nat n + 1) (1 + L_size_rec t a (Z.of_nat n))) as gg; destruct gg.
        symmetry in Heqgg; rewrite <- Zeq_is_eq_bool in Heqgg;omega.
        tauto.
    + remember (Zeq_bool 0 (Z.succ (Z.of_nat n))) as gg;destruct gg.
      symmetry in Heqgg; rewrite <- Zeq_is_eq_bool in Heqgg;omega.
      tauto.
}
remember (Z.to_nat i) as n.
assert (i = Z.of_nat n) by (subst n; symmetry; apply Z2Nat.id; assumption).
subst i.
apply INNAT.
Qed.

Goal typed_lemma_loop_bijection.
Hint loop_bijection,property.
Proof.
intros.
unfold L_loop_l.
SearchAbout Cmod.
replace (Cmod i 1000000) with (i mod 1000000).
replace (Cmod (1000000 + i mod 1000000) 1000000) with ((1000000 + i mod 1000000) mod 1000000).
SearchAbout (_ mod _).
rewrite Z.add_mod_idemp_r.
SearchAbout ( (_ + _) mod _).
SearchAbout (1 * _ = _).
replace (1000000 + i) with (i + 1*1000000) by omega.
rewrite Z_mod_plus_full.
symmetry;apply Zmod_small;omega.
omega.
symmetry.
apply Cmod_cases.
rewrite Zmod_small;omega.
omega.
symmetry;apply Cmod_cases;omega.
Qed.

Goal typed_lemma_loop_injection.
Hint loop_injection,property.
Proof.
Require Import Psatz.
intros i IG0.
unfold L_loop_l.
assert (forall x, x > 0 -> Cmod (x + i) x = Cmod i x). {
 intros x XG0.
 destruct (Cmod_cases i x) as [CM1p CM1rest].
 destruct CM1rest as [CM1n CM1rest].
 destruct (Cmod_cases (x + i) x) as [CM2p CM2rest].
 destruct CM2rest as [CM2n CM2rest].
 pose (Z_mod_plus_full i 1 x) as MOD.
 rewrite Z.mul_1_l in MOD.
 rewrite Z.add_comm in MOD.
 induction i.
  - rewrite CM1p;[|lia|lia].
    rewrite CM2p;[|lia|lia].
    auto.
  - rewrite CM1p;[|lia|lia].
    rewrite CM2p;[|lia|lia].
    auto.
  - contradict IG0;auto.
 }
rewrite H;[auto|lia].
Qed.

Goal typed_lemma_size_rec_bounds.
Hint property,size_rec_bounds.
Proof.
intros.
assert (forall n:nat, 0 <= L_size_rec t a (Z.of_nat n) <= Z.of_nat n) as INNAT. {
  induction n.
  - rewrite FixL_size_rec.
    simpl;omega.
  - rewrite  Nat2Z.inj_succ.
    rewrite FixL_size_rec.
    replace (Zeq_bool 0 (Z.succ (Z.of_nat n))) with false.
    replace (Z.succ (Z.of_nat n) - 1) with (Z.of_nat n) by omega.
    destruct (Zeq_bool 0 (t .[ shift_sint32 a (Z.of_nat n)]));omega.
    remember (Zeq_bool 0 (Z.succ (Z.of_nat n))) as gg;destruct gg.
    symmetry in Heqgg; rewrite <- Zeq_is_eq_bool in Heqgg;omega.
    tauto.
}
subst x.
remember (Z.to_nat i) as n.
replace i with (Z.of_nat n).
- apply INNAT.
- subst n.
  apply Z2Nat.id;assumption.
Qed.

Goal typed_lemma_size_rec_full.
Hint property,size_rec_full.
Proof.
intros.
unfold P_full.
assert (forall l:int, 0 <= l -> ((forall i : int, 0 <= i -> i <= (l - 1) -> 0 <> t .[ shift_sint32 a i]) <->
                                l = L_size_rec t a l)) as GEN. {
  assert (forall l:nat, (forall i : int, 0 <= i -> (Z.to_nat i < l)%nat -> 0 <> t .[ shift_sint32 a i]) <->
          l = Z.to_nat (L_size_rec t a (Z.of_nat l))) as nGEN. {
    assert (forall x, 0 <= L_size_rec t a x) as ZEROleSIZE by admit.
    assert (forall x, L_size_rec t a x <= x) as SIZEleX by admit.
    induction l.
    - rewrite FixL_size_rec.
      simpl.
      split;intro H;[tauto|].
      intros.
      omega.
    - rewrite Nat2Z.inj_succ.
      rewrite FixL_size_rec.
      replace (Z.succ (Z.of_nat l) - 1) with (Z.of_nat l) by omega.
      split.
      + intro.
        replace (Zeq_bool 0 (Z.succ (Z.of_nat l))) with false.
        replace (Zeq_bool 0 (t .[ shift_sint32 a (Z.of_nat l)])) with false.
        replace (1 + L_size_rec t a (Z.of_nat l)) with (Z.succ (L_size_rec t a (Z.of_nat l))).
        rewrite Z2Nat.inj_succ;[|auto].
        apply eq_S.
        apply IHl.
        intros.
        apply H;omega.
        unfold Z.succ.
        replace (Z.of_nat l + 1 - 1) with (Z.of_nat l) by omega.
        omega.
        assert (0 <> (t .[ shift_sint32 a (Z.of_nat l)])). {
          apply H.
          - omega.
          - rewrite Nat2Z.id.
            omega.
        }
        remember (Zeq_bool 0 (t .[ shift_sint32 a (Z.of_nat l)])) as f; destruct f.
        symmetry in Heqf.
        apply Zeq_bool_eq in Heqf.
        contradiction.
        replace (Z.succ (Z.of_nat l) - 1) with (Z.of_nat l) by omega.
        tauto.
        remember (Zeq_bool 0 (Z.succ (Z.of_nat l))) as f; destruct f.
        symmetry in Heqf; apply Zeq_bool_eq in Heqf.
        omega.
        tauto.
      + symmetry in IHl.
        replace (Zeq_bool 0 (Z.succ (Z.of_nat l))) with false.
        remember (Zeq_bool 0 (t .[ shift_sint32 a (Z.of_nat l)])) as f; destruct f.
        intros.
        assert (Z.to_nat (L_size_rec t a (Z.of_nat l)) <= l)%nat as CONTR. {
          pose (SIZEleX (Z.of_nat l)) as SleX.
          rewrite Nat2Z.inj_le.
          rewrite Z2Nat.id.
          assumption.
          auto.
        }
        omega.
        replace (Z.to_nat (1 + L_size_rec t a (Z.of_nat l))) with (S (Z.to_nat (L_size_rec t a (Z.of_nat l)))).
        intros H i ZleI IlL.
        apply eq_add_S in H.
        case (eq_nat_dec (Z.to_nat i) l); intro IeqL.
        apply Zeq_bool_neq.
        replace i with (Z.of_nat l) by (subst l;apply Z2Nat.id;assumption).
        symmetry; assumption.
        assert (Z.to_nat i < l)%nat by omega.
        apply IHl;assumption.
        rewrite <- Z2Nat.inj_succ;[|apply ZEROleSIZE].
        unfold Z.succ.
        pose (ZEROleSIZE (Z.of_nat l)).
        rewrite Z2Nat.inj_iff;omega.
        assert ((Z.succ (Z.of_nat l)) > 0) by omega.
        remember (Zeq_bool 0 (Z.succ (Z.of_nat l))) as f; destruct f.
        symmetry in Heqf; apply Zeq_bool_eq in Heqf.
        omega.
        tauto.
  }
  intro l.
  intro LGE0.
  remember (Z.to_nat l) as x.
  pose (nGEN x) as xGEN.
  rewrite Heqx in xGEN.
  rewrite Z2Nat.id in xGEN by auto.
  assert (forall x, 0 <= L_size_rec t a x) by admit.
  rewrite Z2Nat.inj_iff in xGEN by auto.
  split.
  - intro.
    apply xGEN.
    intro.
    SearchAbout (Z.to_nat _ < Z.to_nat _)%nat.
    intro ZEROLEI.
    rewrite <- Z2Nat.inj_lt.
    intros.
    apply H0;omega.
    omega.
    auto.
  - intros SIZER i ZEROLEI ILEL1.
    apply <- xGEN;[assumption|assumption|].
    SearchAbout (Z.to_nat _ < Z.to_nat _)%nat.
    rewrite <- Z2Nat.inj_lt;omega.
}
replace (999999) with (1000000 - 1);[|omega].
apply GEN;omega.
Qed.

Goal typed_lemma_size_rec_on_one.
Hint property,size_rec_on_one.
Proof.
intros.
rename H0 into ONE_CELL.
rewrite FixL_size_rec.
replace (1 + i - 1) with i;[|omega].
replace (Zeq_bool 0 (t .[ shift_sint32 a i])) with false.
- replace (Zeq_bool 0 (1 + i)) with false;[tauto|].
  replace (Zeq_bool 0 0) with true;[|auto].
  assert ((1 + i) <> 0) by omega.
  remember (Zeq_bool 0 (1 + i)) as f.
  destruct f.
  symmetry in Heqf.
  rewrite <- Zeq_is_eq_bool in Heqf.
  omega.
  trivial.
- rewrite Zeq_is_eq_bool in ONE_CELL.
  destruct (Zeq_bool 0 (t .[ shift_sint32 a i ]));tauto.
Qed.

Goal typed_lemma_size_rec_on_zero.
Hint property,size_rec_on_zero.
Proof.
intros.
rename H0 into ZERO_CELL.
symmetry.
rewrite FixL_size_rec.
replace (1 + i - 1) with i;[|omega].
rewrite <- ZERO_CELL.
replace (Zeq_bool 0 (1 + i)) with false;[tauto|].
replace (Zeq_bool 0 0) with true;[|auto].
assert ((1 + i) <> 0) by omega.
remember (Zeq_bool 0 (1 + i)) as f.
destruct f.
symmetry in Heqf.
rewrite <- Zeq_is_eq_bool in Heqf.
omega.
trivial.
Qed.

Goal typed_loop_post_3.
Hint default,loop,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_put_assert_4.
Hint property,put.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_put_assert_5.
Hint property,put.
Proof.
(* auto with zarith. *)
Qed.


